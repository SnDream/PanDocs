<HTML><HEAD>
  <TITLE>规格</TITLE>
  <META NAME="GENERATOR" CONTENT="nocash XED2HTM converter">
</HEAD><BODY bgcolor="#ffffff" text="#000000" link="#0033cc" vlink="#0033cc" alink="#0033cc">
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="pandocs"></A><FONT SIZE=+2>&nbsp;Pan Docs</FONT></TD></TR></TABLE><BR>
<B>概览<BR>
</B><A HREF="#aboutthepandocs">关于 Pan Docs</A><BR>
<A HREF="#gameboytechnicaldata">Game Boy 技术数据</A><BR>
<A HREF="#memorymap">内存映射</A><BR>
<BR>
<B>输入/输出端口<BR>
</B><A HREF="#videodisplay">视频显示</A><BR>
<A HREF="#soundcontroller">声音控制</A><BR>
<A HREF="#joypadinput">手柄输入</A><BR>
<A HREF="#serialdatatransferlinkcable">串行数据传输 (连接线)</A><BR>
<A HREF="#timeranddividerregisters">定时与分频寄存器</A><BR>
<A HREF="#interrupts">中断</A><BR>
<A HREF="#cgbregisters">CGB 寄存器</A><BR>
<A HREF="#sgbfunctions">SGB 功能</A><BR>
<BR>
<B>CPU 规格<BR>
</B><A HREF="#cpuregistersandflags">CPU 寄存器与标志位</A><BR>
<A HREF="#cpuinstructionset">CPU 指令集</A><BR>
<A HREF="#cpucomparisionwithz80">CPU 与 Z80 的比较</A><BR>
<BR>
<B>卡带<BR>
</B><A HREF="#thecartridgeheader">卡带头部</A><BR>
<A HREF="#memorybankcontrollers">MBC (存储页面控制器)</A><BR>
<A HREF="#gamegeniesharkcheats">Gamegenie/Shark 作弊</A><BR>
<BR>
<B>其他<BR>
</B><A HREF="#powerupsequence">开机流程</A><BR>
<A HREF="#reducingpowerconsumption">降低功耗</A><BR>
<A HREF="#spriterambug">活动块 RAM 的错误</A><BR>
<A HREF="#externalconnectors">外设连接</A><BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="aboutthepandocs"></A><FONT SIZE=+2>&nbsp;关于 Pan Docs</FONT></TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE> =================================================================
               你能在这里知道有关 GAMEBOY 的一切 *
 =================================================================
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>                       * 这种事情开心就好
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>        Pan of -ATX- Document Updated by contributions from:
     Marat Fayzullin, Pascal Felber, Paul Robson, Martin Korth
             CPU, SGB, CGB, AUX specs by Martin Korth
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>                  Last updated 10/2001 by nocash
               Previously updated 4-Mar-98 by kOOPa
</TD></TR></TABLE><BR>
<B>Forward<BR>
</B>The following was typed up for informational purposes regarding the 
inner workings on the hand-held game machine known as GameBoy, 
manufactured and designed by Nintendo Co., LTD. This info is presented 
to inform a user on how their Game Boy works and what makes it "tick". 
GameBoy is copyrighted by Nintendo Co., LTD. Any reference to 
copyrighted material is not presented for monetary gain, but for 
educational purposes and higher learning.<BR>
<BR>
<B>Available Document Formats<BR>
</B>The present version of this document is available in Text and Html format:<BR>
<TABLE><TR><TD><PRE>  http://www.work.de/nocash/pandocs.txt
  http://www.work.de/nocash/pandocs.htm
</TD></TR></TABLE>Also, a copy of this document is included in the manual of newer 
versions of the no$gmb debugger, because of recent piracy attacks (many 
thanks and best wishes go to hell) I have currently no intention to 
publish any such or further no$gmb updates though.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="gameboytechnicaldata"></A><FONT SIZE=+2>&nbsp;Game Boy 技术数据</FONT></TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>  CPU          - 8位 (与 Z80 处理器相似)
  时钟主频     - 4.194304 MHz (SGB 是 4.295454 MHz, CGB 最高可达 8.4 MHz)
  工作 RAM     - 8K 字节 (CGB 为 32K 字节)
  显示 RAM     - 8K 字节 (CGB 为 16K 字节)
  屏幕大小     - 2.6 寸
  分辨率       - 160x144 (20x18 图块)
  最大活动块   - 屏幕最多40个, 每行最多10个
  活动块大小   - 8x8 或者 8x16
  调色板       - BG 1x4, OBJ 2x3 (CGB 为 BG 8x4, OBJ 8x3)
  颜色         - 4级灰度 (CGB 为32768色)
  横向同步     - 9198 KHz (SGB 为 9420 KHz)
  纵向同步     - 59.73 Hz (SGB 为 61.17 Hz)
  声音         - 4通道立体声
  电源         - DC6V 0.7W (GB Pocket 为 DC3V 0.7W, CGB 为 DC3V 0.6W)
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="memorymap"></A><FONT SIZE=+2>&nbsp;内存映射</FONT></TD></TR></TABLE><BR>
Gameboy 的地址总线宽度为16位, 用于 ROM 或 RAM 以及 I/O 寄存器的寻址.<BR>
<BR>
<B>内存映射概览<BR>
</B><TABLE><TR><TD><PRE>  0000-3FFF   16KB ROM Bank 00           (于卡带内, 固定为 Bank 00)
  4000-7FFF   16KB ROM Bank 01 到 NN     (于卡带内, 可切 Bank)
  8000-9FFF   8KB 显示 RAM        (VRAM) (在 CGB 模式中可以切 Bank 0 或 1)
  A000-BFFF   8KB 外部 RAM   (ERAM/SRAM) (于卡带内, 如果条件允许可切 Bank)
  C000-CFFF   4KB 工作 RAM Bank 0 (WRAM)
  D000-DFFF   4KB 工作 RAM Bank 1 (WRAM) (在 CGB 模式中可以切 Bank 1 到 7)
  E000-FDFF   与 C000-DDFF 一致   (ECHO) (一般不用)
  FE00-FE9F   活动块属性表        (OAM)
  FEA0-FEFF   不可用
  FF00-FF7F   I/O 端口
  FF80-FFFE   高位 RAM            (HRAM)
  FFFF        中断启用寄存器
</TD></TR></TABLE><BR>
<B>ROM 首个 Bank 的跳转向量<BR>
</B>下面的地址可作为跳转向量:<BR>
<TABLE><TR><TD><PRE>  0000,0008,0010,0018,0020,0028,0030,0038   通过使用 RST 指令
  0040,0048,0050,0058,0060                  通过中断
</TD></TR></TABLE>然而,在你的程序不使用任何或部分 RST 指令或者中断时, 你可以将这些内存另作他用. RST 是一个1字节的操作码, 除了目标地址是固定的之外, 与 CALL 操作码的工作方式相似.<BR>
<BR>
<B>ROM 首个 Bank 的卡带头部<BR>
</B>内存 0100-014F 为卡带头部. 这个区域含有程序的信息, 程序的入口, 校验和, 所用 MBC 芯片的信息, ROM 和 RAM 的大小等等. 这个区域的大部分字节需要正确设定. 更多详情请阅读卡带头部相关章节.<BR>
<BR>
<B>外部存储与硬件<BR>
</B>内存 0000-7FFF 和 A000-BFFF 一般用于连接外部硬件. 第一个区域一般用于 ROM 寻址 (当然是只读的), 有着 MBC 的卡带会额外使用这个区域来输出数据 (只写) 到 MBC 芯片. 第二个区域一般用于外部 RAM 的寻址, 或者其他外部硬件的寻址 (实时时钟等). 外部 RAM 常常配有电池, 用于在 Gameboy 关机时或者卡带被拔出时仍能维持已记录下的游戏进度以及高分表之类的东西. 具体详情请阅读 MBC 相关章节.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="videodisplay"></A><FONT SIZE=+2>&nbsp;视频显示</FONT></TD></TR></TABLE><BR>
<B>视频 I/O 寄存器<BR>
</B><A HREF="#lcdcontrolregister">LCD 控制寄存器</A><BR>
<A HREF="#lcdstatusregister">LCD 状态寄存器</A><BR>
<A HREF="#lcdinterrupts">LCD 中断</A><BR>
<A HREF="#lcdpositionandscrolling">LCD 位置与卷轴</A><BR>
<A HREF="#lcdmonochromepalettes">LCD 单色调色板</A><BR>
<A HREF="#lcdcolorpalettescgbonly">LCD 彩色调色板 (仅 CGB)</A><BR>
<A HREF="#lcdvrambankcgbonly">LCD VRAM Bank (仅 CGB)</A><BR>
<A HREF="#lcdoamdmatransfers">LCD OAM DMA 传输</A><BR>
<A HREF="#lcdvramdmatransferscgbonly">LCD VRAM DMA 传输 (仅 CGB)</A><BR>
<BR>
<B>Video Memory<BR>
</B><A HREF="#vramtiledata">VRAM 图块数据</A><BR>
<A HREF="#vrambackgroundmaps">VRAM BG Map</A><BR>
<A HREF="#vramspriteattributetableoam">VRAM 活动块属性表 (OAM)</A><BR>
<A HREF="#accessingvramandoam">访问 VRAM 与 OAM</A><BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdcontrolregister"></A><FONT SIZE=+2>&nbsp;LCD 控制寄存器</FONT></TD></TR></TABLE><BR>
<B>FF40 - LCDC - LCD 控制 (读写)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7 - 开启 LCD 显示                 (0=关, 1=开)
  Bit 6 - 窗口图块 Map 显示选择         (0=9800-9BFF, 1=9C00-9FFF)
  Bit 5 - 开启窗口显示                  (0=关, 1=开)
  Bit 4 - BG & 窗口图块数据源选择       (0=8800-97FF, 1=8000-8FFF)
  Bit 3 - BG 图块 Map 显示选择          (0=9800-9BFF, 1=9C00-9FFF)
  Bit 2 - OBJ (活动块) 大小             (0=8x8, 1=8x16)
  Bit 1 - 开启 OBJ (活动块) 显示        (0=关, 1=开)
  Bit 0 - BG 显示 (对于 CGB, 见下)      (0=关, 1=开)
</TD></TR></TABLE><BR>
<B>LCDC.7 - 开启 LCD 显示<BR>
</B>警告: 关闭 LCD 的操作 (Bit 7 由 1 设为 0) 仅可在 V-Blank 内进行, 在 V-Blank 时段之外关闭显示可能损坏硬件. 这是一个非常严重的问题, 据报道任天堂已宣布拒绝所有不符合这个规则的游戏. <BR>
V-Blank 可以利用 LY 大于等于 144 来判断. 当显示关闭时屏幕呈现空白 (白色), 此时 VRAM 和 OAM 可以随意访问.<BR>
<BR>
--- LCDC.0 根据 Gameboy 类型有不同意义 ---<BR>
<BR>
<B>LCDC.0 - 1) 单色 Gameboy 和 SGB: BG 显示<BR>
</B>当 Bit 0 处于清除时, BG 变为空白. 窗口和活动块仍可能在显示 (如果启用了 Bit 1 或 Bit 5).<BR>
<BR>
<B>LCDC.0 - 2) CGB 运行于 CGB 模式: BG 和窗口优先级<BR>
</B>当 Bit 0 处于清除时, BG 和窗口失去他们的优先级 - 活动块将总是显示在 BG 和窗口之上, 独立于 OAM 与 BG Map 属性中的优先级设置.<BR>
<BR>
<B>LCDC.0 - 3) CGB 运行于非 CGB 模式: BG 和窗口显示<BR>
</B>当 Bit 0 处于清除时, BG 和窗口变为空白, 在此情况下窗口显示位 (Bit 5) 将被忽略. 只有活动块仍可能在显示 (如果启用了Bit 1).<BR>
这可能造成兼容性问题 - 任何关闭了屏幕, 但仍想显示窗口的单色游戏可能不能在 CGB 上正确工作.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdstatusregister"></A><FONT SIZE=+2>&nbsp;LCD 状态寄存器</FONT></TD></TR></TABLE><BR>
<B>FF41 - STAT - LCDC 状态   (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 6 - LYC=LY 一致中断                (1=启用) (读写)
  Bit 5 - 模式 2 OAM 中断                (1=启用) (读写)
  Bit 4 - 模式 1 V-Blank 中断            (1=启用) (读写)
  Bit 3 - 模式 0 H-Blank 中断            (1=启用) (读写)
  Bit 2 - 一致标志位        (0:LYC&lt;&gt;LY, 1:LYC=LY) (只读)
  Bit 1-0 - 模式标志位           (模式 0-3, 见下) (只读)
            0: 处于 H-Blank
            1: 处于 V-Blank
            2: 处于检索 OAM-RAM 的状态
            3: 处于传送数据至 LCD 驱动的状态
</TD></TR></TABLE><BR>
STAT 的低两位表示当前 LCD 控制器的状态.<BR>
<TABLE><TR><TD><PRE>  模式 0: LCD 控制器处于 H-Blank 时段,
          CPU 可以访问显示 RAM (8000h-9FFFh) 和 OAM (FE00h-FE9Fh).
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>  模式 1: LCD 控制器处于 V-Blank 时段
          (或者屏幕处于关闭状态),
          CPU 可以访问显示 RAM (8000h-9FFFh) 和 OAM (FE00h-FE9Fh).
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>  模式 2: LCD 控制器正在从 OAM 存储中读取数据.
          CPU &lt;不可以&gt;在这个时段访问 OAM 存储 (FE00h-FE9Fh).
</TD></TR></TABLE><BR>
<TABLE><TR><TD><PRE>  模式 3: LCD 控制器正在从 OAM 和 VRAM 中读取数据,
          CPU &lt;不可以&gt;在这个时段访问 OAM 和 VRAM.
          CGB 模式: 也不可以放访问调色板数据 (FF69,FF6B).
</TD></TR></TABLE><BR>
下面是当显示开启时的典型时序:<BR>
<TABLE><TR><TD><PRE>  模式 2  2_____2_____2_____2_____2_____2___________________2____
  模式 3  _33____33____33____33____33____33__________________3___
  模式 0  ___000___000___000___000___000___000________________000
  模式 1  ____________________________________11111111111111_____
</TD></TR></TABLE><BR>
模式标志位经过值 0, 2, 3 一个时段大约需要 109 微秒. 模式 0 出现大约 48.6 微秒, 模式 2 大约 19 微秒, 模式 3 大约 41微秒. 这个循环每 16.6 毫秒被 VBlank (模式 1) 打断一次. 模式标志位设为 1 大约持续 1.08 毫秒.<BR>
<BR>
模式 0 出现大约 201-207 个 CPU 时钟, 模式 2 大约 77-83 个 CPU 时钟, 模式 3 大约 169 - 175 个 CPU 时钟. 完整经过这几个状态的时段耗费 456 个 CPU 时钟. VBlank 持续 4560 个 CPU 时钟. 每 70224 个 CPU 时钟产生一次完整的屏幕刷新.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdinterrupts"></A><FONT SIZE=+2>&nbsp;LCD 中断</FONT></TD></TR></TABLE><BR>
<B>INT 40 - V-Blank 中断<BR>
</B>V-Blank 中断在普通 GB 上每秒产生 59.7 次, 在 SGB 上每秒产生 61.1 次. 这个中断产生于 V-Blank 时段的开始 (LY=144).<BR>
这个时段内视频硬件不使用 VRAM, 所以此时 VRAM 可以随意访问. 这个时段大约持续 1.1 毫秒.<BR>
<BR>
<B>INT 48 - LCDC 状态中断<BR>
</B>根据 STAT 寄存器 ($FF40) 的设置状态, 会有多种产生这个中断的原因. 一个最常见的原因是当视频硬件要重绘一条给定的 LCD 行时告知使用者. 这个在动态调整 SCX/SCY 寄存器 ($FF43/$FF42) 来实现特殊的画面效果时非常有用.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdpositionandscrolling"></A><FONT SIZE=+2>&nbsp;LCD 位置与卷轴</FONT></TD></TR></TABLE><BR>
<B>FF42 - SCY - 卷轴 Y   (读写)<BR>
FF43 - SCX - 卷轴 X   (读写)<BR>
</B>指定LCD屏幕左上角在在背景映射表（大小256x256像素，即32x32画片）中的位置<BR>
X/Y的可选数值范围是0-255。当绘图操作超出背景映射表的下边界（右边界）时，视频控制器会自动回程到背景映射表的上部（左部）。<BR>
<BR>
<B>FF44 - LY - LCDC Y 坐标 (只读)（译注：视频控制器纵坐标寄存器）<BR>
</B>LY寄存器指明当前被传输到LCD驱动器的数据是哪一行。
LY寄存器可取0到153之间的任意数据。
当数据为144到153之间时，表明在纵向回程周期（V-Blank，译注：电子束扫描线在扫描完毕并准备生成新一帧时，必须回到起点，这段时间即纵向回程周期。液晶显示的Gameboy从NES继承了该显示机制，尽管液晶屏并不需要）
写操作将重置计数器。<BR>
<BR>
<B>FF45 - LYC - LY 比较  (读写)<BR>
</B>Gameboy会一直比较LYC寄存器和LY寄存器的值。当二者值相同时，STAT寄存器的冲突位会被置1，并发起STAT中断请求（若启用）。
<BR>
<BR>
<B>FF4A - WY - 窗口 Y 位置 (读写)<BR>
FF4B - WX - 窗口 X 位置 (值 = X 位置 + 7) (读写)<BR>
</B>指定窗口区域的左上角坐标。（该窗口是另一个背景区域，并且可以显示在普通背景之上）。就像和普通背景交互那样，OBJs（精灵）依然可以显示在窗口之上或之下。<BR>
当坐标设置为WX=0..166，WY=0..143范围内时可以看见窗口。若在窗口左上角取坐标WX=7，WY=0，则它将完全覆盖普通背景。<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdmonochromepalettes"></A><FONT SIZE=+2>&nbsp;LCD 单色调色板</FONT></TD></TR></TABLE><BR>
<B>FF47 - BGP - 背景调色板数据  (读写) - 仅非 CGB 模式<BR>
</B>该寄存器指派背景和窗口画片的颜色编号的灰度等级。<BR>
<TABLE><TR><TD><PRE>  比特位 7-6 - 颜色编号3的灰度等级
  比特位 5-4 - 颜色编号2的灰度等级
  比特位 3-2 - 颜色编号1的灰度等级
  比特位 1-0 - 颜色编号0的灰度等级
</TD></TR></TABLE>四种可选的灰度等级是：<BR>
<TABLE><TR><TD><PRE>  0  白色
  1  浅灰
  2  深灰
  3  黑色
</TD></TR></TABLE>在CGB模式中，颜色调色板则从CGB调色板存储中调用。<BR>
<BR>
<B>FF48 - OBP0 - 活动块调色板 0 数据 (读写) - 仅限非 CGB 模式<BR>
</B>该寄存器指定精灵调色板0的灰度等级。它用起来和背景调色板寄存器BGP（FF47）完全一样，除过没有使用最低的两个数据位。这是因为精灵数据00是透明色。<BR>
<BR>
<B>FF49 - OBP1 - 活动块调色板 1 数据 (读写) - 仅限非 CGB 模式<BR>
</B>该寄存器指定精灵调色板1的灰度等级。它用起来和背景调色板寄存器BGP（FF47）完全一样，除过没有使用最低的两个数据位。这是因为精灵数据00是透明色。<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdcolorpalettescgbonly"></A><FONT SIZE=+2>&nbsp;LCD 彩色调色板 (仅 CGB)</FONT></TD></TR></TABLE><BR>
<B>FF68 - BCPS/BGPI - 仅 CGB 模式 - 背景调色板索引<BR>
</B>该寄存器用来寻址CGB的背景调色板存储的一个字节。该存储中每两个字节定义一个颜色的值。前8个字节定义了调色板0（BGP0）的颜色0-3，BGP1-7以此类推。<BR>
<TABLE><TR><TD><PRE>  比特位 0-5   索引 (00-3F)
  比特位 7     自动递增  (0=禁用， 1=写操作后递增)
</TD></TR></TABLE>通过寄存器FF69，可以读取/写入指定的索引地址。当自动递增位被启用，那么每次&lt;写入&gt;FF69之后索引都会自动递增。而从FF69&lt;读取&gt;数据不会启用自动递增，因此在这种情况下需要手动递增索引。<BR>
<BR>
<B>FF69 - BCPD/BGPD - 仅限 CGB 模式 - 背景调色板数据<BR>
</B>通过寄存器FF68寻址，该寄存器可读/写CGB的背景调色板存储。<BR>
每种颜色由两个字节定义 (比特位 0-7 在第一个字节).<BR>
<TABLE><TR><TD><PRE>  比特位 0-4   红色的强度   (00-1F)
  比特位 5-9   绿色的强度 (00-1F)
  比特位 10-14 蓝色的强度  (00-1F)
</TD></TR></TABLE>和显存（VRAM）一样，当LCD控制器从中读取数据时，调色板存储中的数据不可读/写。(此时即STAT寄存器指示的模式3).<BR>
注：在最开始，所有背景颜色都被初始化为白色。<BR>
<BR>
<B>FF6A - OCPS/OBPI - 仅限 CGB 模式 - 活动块调色板索引<BR>
FF6B - OCPD/OBPD - 仅限 CGB 模式 - 活动块调色板数据<BR>
</B>和上文描述的背景调色板一样，这两个寄存器用来初始化精灵调色板OBP0-7。注意，每一个OBP调色板都可以定义四个颜色，但是每个调色板只会显示出颜色1-3。颜色0一直是透明色，并且可以被初始化为一个任意一个无所谓的值。<BR>
注：在最开始，所有精灵的颜色都是未初始化的。<BR>
<BR>
<B>CGB的RGB颜色转换<BR>
</B>注意，在个人电脑上开发图像时，RGB数值在VGA显示器上和CGB的显示屏有不同的表现：<BR>
浓度最高的配色会显示出浅灰色，而不是白色。色彩浓度不是线性的。10h-1Fh之间的数值会显得非常亮，而中等和暗色在 00h-0Fh 之间。<BR>
CGB的显示屏会非常奇怪地混合颜色。仅仅增加一种R，G，B颜色的浓度也会影响其他两个R，G，B颜色。<BR>
举例来说，颜色值03EFh（蓝色=0，绿色=1Fh，红色=0Fh）在VGA显示器上看起来是荧光绿，然而在CGB上却是一个无比正确的褪色黄。<BR>
<BR>
<B>GBA的RGB颜色转换<BR>
</B>尽管GBA被描述为可以兼容CGB游戏，但实际上大部分CGB游戏在GBA上完全不能玩，因为大部分颜色都看不见（黑色）。当然，像黑色和白色这样的颜色在CGB和GBA上是一样的，但是中间浓度的颜色却被处理得完全不一样。<BR>
在范围00h..0Fh区间的颜色浓度是看不见的/显示为黑色（除非偶尔在非常好的光照条件之下，同时以特定角度盯着屏幕），不幸的是，这部分区间的浓度通常被大部分已存在的CGB游戏用作中间及较暗的颜色。<BR>
新一些的CGB游戏可以在检测到GBA硬件时更换调色板数据，以避免这种效应。一个相对简单的方法是使用公式GBA=CGB
    /2+10h来转换每一个RGB颜色浓度。或许结果并不完美，并且（当能看见颜色时）颜色混合看起来也很奇怪，但聊胜于无，至少比没有转换好一些。<BR>
另外，这些颜色转换方法用GBA硬件实施的话是及其简单的，但显而易见，任天堂并没有这么做。所以他们是如何声称，本印章（译注，指任天堂在每个游戏卡带外的圆形印章图样）是为您提供杰出工艺及其它林林总总的担保？<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdvrambankcgbonly"></A><FONT SIZE=+2>&nbsp;LCD VRAM Bank (仅 CGB)</FONT></TD></TR></TABLE><BR>
<B>FF4F - VBK - 仅 CGB 模式 - VRAM Bank<BR>
</B>这个 1 位的寄存器用于选择当前的视频 RAM (VRAM) 的 Bank.<BR>
<TABLE><TR><TD><PRE>  Bit 0 - VRAM Bank (0-1)
</TD></TR></TABLE>Bank 0 含有 192 个图块, 和两张 BG Map, 仅用于单色游戏. Bank 1 还有另外的 192 个图块, 以及搭配 Bank 0 中的 BG Map 使用的颜色属性 Map.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdoamdmatransfers"></A><FONT SIZE=+2>&nbsp;LCD OAM DMA 传输</FONT></TD></TR></TABLE><BR>
<B>FF46 - DMA - DMA 传输与开始地址 (只写)<BR>
</B>Writing to this register launches a DMA transfer from ROM or RAM to OAM 
memory (sprite attribute table). The written value specifies the 
transfer source address divided by 100h, ie. source & destination are:<BR>
<TABLE><TR><TD><PRE>  Source:      XX00-XX9F   ;XX in range from 00-F1h
  Destination: FE00-FE9F
</TD></TR></TABLE>It takes 160 microseconds until the transfer has completed (80 
microseconds in CGB Double Speed Mode), during this time the CPU can 
access only HRAM (memory at FF80-FFFE). For this reason, the programmer 
must copy a short procedure into HRAM, and use this procedure to start 
the transfer from inside HRAM, and wait until the transfer has finished:<BR>
<TABLE><TR><TD><PRE>   ld  (0FF46h),a ;start DMA transfer, a=start address/100h
   ld  a,28h      ;delay...
  wait:           ;total 5x40 cycles, approx 200ms
   dec a          ;1 cycle
   jr  nz,wait    ;4 cycles
</TD></TR></TABLE>Most programs are executing this procedure from inside of their VBlank 
procedure, but it is possible to execute it during display redraw also, 
allowing to display more than 40 sprites on the screen (ie. for example 
40 sprites in upper half, and other 40 sprites in lower half of the 
screen).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="lcdvramdmatransferscgbonly"></A><FONT SIZE=+2>&nbsp;LCD VRAM DMA 传输 (仅 CGB)</FONT></TD></TR></TABLE><BR>
<B>FF51 - HDMA1 - 仅 CGB 模式  - 新 DMA 来源地址高位<BR>
FF52 - HDMA2 - 仅 CGB 模式  - 新 DMA 来源地址低位<BR>
FF53 - HDMA3 - 仅 CGB 模式  - 新 DMA 目标地址高位<BR>
FF54 - HDMA4 - 仅 CGB 模式  - 新 DMA 目标地址低位<BR>
FF55 - HDMA5 - 仅 CGB 模式  - 新 DMA 长度/模式/启动<BR>
</B>这些寄存器用于发起一次从 ROM 或 RAM 到 VRAM 的 DMA 传送. 来源首地址定于 0000-7FF0 或者 A000-DFF0, 地址低四位将被忽略 (处理为0). 目标首地址定于 8000-9FF0, 地址低四位将被忽略 (处理为0), 地址高三位也将被忽略 (目标总是在VRAM内).<BR>
<BR>
写入 FF55 启动传输, FF55 的低七位指定了传输长度 (值 = 传输长度 / 10h - 1). 例如, 10h-800h的长度可以对应指定值为00h-7Fh. FF55 的最高位表示传输模式:<BR>
<BR>
<B>Bit7=0 - 通用 DMA<BR>
</B>当使用这种传输方式时, 所有数据将一次性传输. 程序的执行将停机, 直到传输完成. 需要注意通用 DMA 只会直接尝试复制数据, 甚至在 LCD 控制器正在访问 VRAM 时也是如此. 所以通用 DMA 只能在屏幕关闭时, 或处于 V-Blank 时, 再或者 (在传输小块的情况) 处于 H-Blank 时.<BR>
程序将在传输完成时继续执行, 此时 FF55 的值为 0FFh.<BR>
<BR>
<B>Bit7=1 - H-Blank DMA<BR>
</B>H-Blank DMA 在每个 H-Blank 中传输 10h 字节的数据. 例如, 在 LY=0-143 的时候进行传输, 在 V-Blank 时数据暂停传输 (LY=144-153), 但是当 LY=00 时传输将继续进行. 程序在每个传输分片进行时停机, 但是程序将在每个分片之间的 '空闲时刻' 继续执行.<BR>
需要注意程序不能在传输结束之前改变目标 VRAM 的 Bank (FF4F), 或者来源 ROM/RAM 的 Bank (如果传输的数据来自于可切 Bank 的存储)!<BR>
从寄存器 FF55 读取将返回传输剩余的长度 (值 = 传输长度 / 10h - 1), 值 0FFh 代表传输已经完成. 要终止一个活动的 H-Blank 传输可以往 FF55 的 Bit 7 写入 0. 在这种情况下从 FF55 中读取数据, 返回值的低七位将是任意值, 但最高位将读取到 "1" .<BR>
<BR>
<B>确认 DMA 传输是否活动<BR>
</B>读取 FF55 的 Bit 7 可以用于确认 DMA 传输是否活动 (1= 不活动, 0= 活动). 这种方式可以在任何情况下工作 - 在通用传输完成后, 在 H-Blank 传输结束之后, 以及手动终止 H-Blank 传输之后均可.<BR>
<BR>
<B>传输时间<BR>
</B>普速模式和倍速模式均需要 8 微秒来传输一个 10h 字节块. 相当于普速模式下的 8 个周期, 倍速模式下的 16 个 '快' 周期.<BR>
较旧的 MBC (如 MBC1 到 3, 即 MBC5 之前) 与慢速 ROM 不保证支持通用或 H-Blank DMA, 因为即使程序运行于普速模式, 传输均是以 2 字节每毫秒的速度进行.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="vramtiledata"></A><FONT SIZE=+2>&nbsp;VRAM 图块数据</FONT></TD></TR></TABLE><BR>
图块 (Tile) 数据存储于 VRAM 地址 8000h-97FFh, 这个区域定义了 192 个图块的位图. 在 CGB 模式下, 因为使用了 0:8000h-97FFh 和 1:8000h-97FFh 的内存, 所以可定义 384 个图块.<BR>
<BR>
每个图块为 8x8 像素大小, 色深为 4 色/灰度. 图块可作为背景/窗口 Map 的一个部分显示, 也/或可以作为 OAM 图块 (前景活动块) 显示. 注意前景活动块的颜色 0 为透明, 所以只有 3 种颜色可用.<BR>
<BR>
如前所述, 两张图块样式表 (Pattern Table) 位于 $8000-8FFF 和 $8800-97FF. 第一张可以用于活动块和背景. 图块号从 0 编号到 255. 第二张可以用于背景和窗口显示, 图块号从 -128 编号到 127.<BR>
<BR>
每个图块占有 16 个字节, 其中每 2 个字节代表一行:<BR>
<TABLE><TR><TD><PRE>  Byte 0-1  第一行 (最上方的 8 个像素)
  Byte 2-3  下一行
  以此类推.
</TD></TR></TABLE>对于每条线, 第一个字节定义了每个像素颜色号的低位, 第二个字节定义了每个像素颜色号的高位. 另外, Bit 7 是最左边的像素, Bit 0 是最右边的像素.<BR>
<BR>
所以, 每个像素有范围 0-3 的颜色号, 颜色号将依据当前的调色板转换成实际颜色 (或者灰度). 调色板定义在寄存器 FF47-FF49 (非 CGB 模式), 和 FF68-FF6B (CGB 模式).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="vrambackgroundmaps"></A><FONT SIZE=+2>&nbsp;VRAM BG Map</FONT></TD></TR></TABLE><BR>
Gameboy 有两张 32x32 的图块 BG Map (背景分布) 于 VRAM 地址 9800h-9BFFh 和 9C00h-9FFFh. 每张可以用于显示 "普通" 的背景, 也可以用于显示 "窗口" 背景.<BR>
<BR>
<B>BG Map 图块号<BR>
</B>VRAM 中作为 BG 图块 Map 的区域包含用于显示的图块所对应的编号. 这个区域组成为 32 行, 每行 32 个字节. 每个字节包含一个用于显示的图块编号. 图块样式表从位于 $8000-8FFF 或者 $8800-97FF 的图块数据表中得来. 第一种情况 ($8000-8FFF), 图块样式表以从 0 到 255 的无符号数作为编号 (如, 样式 #0 位于地址 $8000). 第二种情况 ($8800-97FF), 样式表以 -128 到 127 的有符号数作为编号 (如, 样式 #0 位于地址 $9000). 用于背景的图块数据表地址可通过 LCDC 寄存器选择.<BR>
<BR>
<B>BG Map 属性 (仅 CGB 模式)<BR>
</B>在 CGB 模式中, 有一张附加的存于 VRAM Bank 1 的 32x32 字节 Map (每个字节一一对应 VRAM Bank 0 中的 BG 图块 Map, 用于定义图块属性):<BR>
<TABLE><TR><TD><PRE>  Bit 0-2  背景调色板编号           (BGP0-7)
  Bit 3    图块 VRAM Bank 号        (0=Bank 0, 1=Bank 1)
  Bit 4    不使用
  Bit 5    水平翻转                 (0=普通, 1=水平翻转)
  Bit 6    垂直翻转                 (0=普通, 1=垂直翻转)
  Bit 7    BG 与 OAM 优先级         (0=根据 OAM 优先位, 1=BG 优先)
</TD></TR></TABLE>当 Bit 7 处于设置时, 对应的 BG 图块将有高于所有活动块的优先度 (忽略 OAM 存储中所设的优先位). 另外, 在 LCDC 寄存器的 Bit 0 是主优先标志, 这个标志处于清除时, 标志的优先级位于其他所有优先度设置之上.<BR>
<BR>
因为一个背景图块的大小是 8x8 像素, 所以一张 BG Map 能表示一张 256x256 像素的图像, 这张图像中的 160x144 可以被显示在 LCD 屏幕上.<BR>
<BR>
<B>普通背景 (BG)<BR>
</B>SCY 和 SCX 寄存器可用于滚动背景, 允许在整张 256x256 像素的 BG Map 中选择可见的 160x144 像素区域的来源. 背景在屏幕上环绕 (如, 当背景的一部分穿出了屏幕, 这一部分将显示背景另一侧的内容.)<BR>
<BR>
<B>窗口<BR>
</B>除了背景, 还有一个 "窗口" 叠放与背景层之上. 这个窗口是不可滚动的, 总是从 (Map 的) 左上角开始显示. 窗口在屏幕上的位置可以通过 WX 和 WY 寄存器调节. 窗口左上角在屏幕的坐标是 WX-7,WY. 用于窗口的图块存于图块数据表. 背景和窗口始终使用统一张图块数据表.<BR>
<BR>
背景和窗口两者都可以各自独立通过 LCDC 寄存器中对应的位来开启或关闭.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="vramspriteattributetableoam"></A><FONT SIZE=+2>&nbsp;VRAM Sprite Attribute Table (OAM)</FONT></TD></TR></TABLE><BR>
GameBoy video controller can display up to 40 sprites either in 8x8 or 
in 8x16 pixels. Because of a limitation of hardware, only ten sprites 
can be displayed per scan line. Sprite patterns have the same format as 
BG tiles, but they are taken from the Sprite Pattern Table located at 
$8000-8FFF and have unsigned numbering.<BR>
<BR>
Sprite attributes reside in the Sprite Attribute Table (OAM - Object 
Attribute Memory) at $FE00-FE9F. Each of the 40 entries consists of four 
bytes with the following meanings:<BR>
<BR>
<B>Byte0 - Y Position<BR>
</B>Specifies the sprites vertical position on the screen (minus 16).<BR>
An offscreen value (for example, Y=0 or Y&gt;=160) hides the sprite.<BR>
<BR>
<B>Byte1 - X Position<BR>
</B>Specifies the sprites horizontal position on the screen (minus 8).<BR>
An offscreen value (X=0 or X&gt;=168) hides the sprite, but the sprite<BR>
still affects the priority ordering - a better way to hide a sprite is 
to set its Y-coordinate offscreen.<BR>
<BR>
<B>Byte2 - Tile/Pattern Number<BR>
</B>Specifies the sprites Tile Number (00-FF). This (unsigned) value selects 
a tile from memory at 8000h-8FFFh. In CGB Mode this could be either in 
VRAM Bank 0 or 1, depending on Bit 3 of the following byte.<BR>
In 8x16 mode, the lower bit of the tile number is ignored. Ie. the upper 
8x8 tile is "NN AND FEh", and the lower 8x8 tile is "NN OR 01h".<BR>
<BR>
<B>Byte3 - Attributes/Flags:<BR>
</B><TABLE><TR><TD><PRE>  Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
         (Used for both BG and Window. BG color 0 is always behind OBJ)
  Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
  Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
  Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
  Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
  Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)
</TD></TR></TABLE><BR>
<B>Sprite Priorities and Conflicts<BR>
</B>When sprites with different x coordinate values overlap, the one with 
the smaller x coordinate (closer to the left) will have priority and 
appear above any others. This applies in Non CGB Mode only.<BR>
When sprites with the same x coordinate values overlap, they have 
priority according to table ordering. (i.e. $FE00 - highest, $FE04 - 
next highest, etc.) In CGB Mode priorities are always assigned like 
this.<BR>
<BR>
Only 10 sprites can be displayed on any one line. When this limit is 
exceeded, the lower priority sprites (priorities listed above) won't be 
displayed. To keep unused sprites from affecting onscreen sprites set 
their Y coordinate to Y=0 or Y=&gt;144+16. Just setting the X coordinate to 
X=0 or X=&gt;160+8 on a sprite will hide it but it will still affect other 
sprites sharing the same lines.<BR>
<BR>
<B>Writing Data to OAM Memory<BR>
</B>The recommened method is to write the data to normal RAM first, and to 
copy that RAM to OAM by using the DMA transfer function, initiated 
through DMA register (FF46).<BR>
Beside for that, it is also possible to write data directly to the OAM 
area by using normal LD commands, this works only during the H-Blank and 
V-Blank periods. The current state of the LCD controller can be read out 
from the STAT register (FF41).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="accessingvramandoam"></A><FONT SIZE=+2>&nbsp;访问 VRAM 和 OAM</FONT></TD></TR></TABLE><BR>
<B>警告<BR>
</B>当 LCD 控制器绘制屏幕时, 它将直接读取视频存储 (VRAM) 和 OAM. 在这个时期内 Gameboy CPU 不可访问 VRAM 和 OAM. 在这时, 任何对 VRAM/OAM 的写入尝试将被忽略 (数据保持不变). 任何对 VRAM/OAM 的读取尝试将返回未定义数据 (一般来说是值 0FFh).<BR>
<BR>
因为如此, 程序需要在写入或读取 VRAM/OAM 之前确认它们能否访问. 一般是通过读取 STAT 寄存器的模式位来确认的. 在做这个确认步骤时 (在下面的例子中说明) 你需要确认在等待循环和接下来的内存访问之间没有中断产生 - 对应的存储只在等待循环完成后的几个周期内能确保被访问.<BR>
<BR>
<B>VRAM (内存位于 8000h-9FFFh) 可以在模式 0-2 之间访问<BR>
</B><TABLE><TR><TD><PRE>  Mode 0 - H-Blank 时期
  Mode 1 - V-Blank 时期
  Mode 2 - 检索 OAM 时期
</TD></TR></TABLE>一个等待 VRAM 可访问的典型程序可以是:<BR>
<TABLE><TR><TD><PRE>  ld   hl,0FF41h    ;-STAT 寄存器
 @@wait:            ;\
  bit  1,(hl)       ; 等待直到模式为 0 或 1
  jr   nz,@@wait    ;/
</TD></TR></TABLE>就算程序在模式 0 或 1 的 &lt;结尾&gt; 执行, 因为这两种模式后面跟随着同样允许访问 VRAM 的模式 2 ,依旧能够推定此时 VRAM 仍有一些周期可以访问.<BR>
在 CGB 模式下, 一种写入 VRAM 的替代方式是使用 HDMA 功能 (FF51-FF55).<BR>
<BR>
<B>OAM (内存位于 FE00h-FE9Fh) 可以在模式 0-1 之间访问<BR>
</B><TABLE><TR><TD><PRE>  Mode 0 - H-Blank 时期
  Mode 1 - V-Blank 时期
</TD></TR></TABLE>
除了这个方式之外, OAM 可以通过 DMA 功能 (FF46) 在任意时刻访问. 直接读写 OAM 时, 一个等待 OAM 存储可访问的典型程序可以是:<BR>
<TABLE><TR><TD><PRE>  ld   hl,0FF41h    ;-STAT 寄存器
 @@wait1:           ;\
  bit  1,(hl)       ; 等待直到模式 -不为- 0 或 1
  jr   z,@@wait1    ;/
 @@wait2:           ;\
  bit  1,(hl)       ; 等待直到模式 0 或 1 -开始-
  jr   nz,@@wait2   ;/
</TD></TR></TABLE>两个等待循环确保在程序完成后能维持在模式 0 或 1 中几个周期. 在 V-Blank 时期推荐跳过整个程序 - 同时更推荐在大部分情况下使用前面提到的 DMA 功能.<BR>
<BR>
<B>备注<BR>
</B>当显示关闭时, VRAM 和 OAM 都可以在任意时刻访问. 这样的缺点是屏幕在这个时期显示空白, 所以只推荐在初始化时关闭显示.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundcontroller"></A><FONT SIZE=+2>&nbsp;Sound Controller</FONT></TD></TR></TABLE><BR>
<A HREF="#soundoverview">Sound Overview</A><BR>
<A HREF="#soundchannel1tonesweep">Sound Channel 1 - Tone & Sweep</A><BR>
<A HREF="#soundchannel2tone">Sound Channel 2 - Tone</A><BR>
<A HREF="#soundchannel3waveoutput">Sound Channel 3 - Wave Output</A><BR>
<A HREF="#soundchannel4noise">Sound Channel 4 - Noise</A><BR>
<A HREF="#soundcontrolregisters">Sound Control Registers</A><BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundoverview"></A><FONT SIZE=+2>&nbsp;Sound Overview</FONT></TD></TR></TABLE><BR>
There are two sound channels connected to the output terminals SO1 and 
SO2. There is also a input terminal Vin connected to the cartridge. It 
can be routed to either of both output terminals. GameBoy circuitry 
allows producing sound in four different ways:<BR>
<BR>
<TABLE><TR><TD><PRE>   Quadrangular wave patterns with sweep and envelope functions.
   Quadrangular wave patterns with envelope functions.
   Voluntary wave patterns from wave RAM.
   White noise with an envelope function.
</TD></TR></TABLE><BR>
These four sounds can be controlled independantly and then mixed 
separately for each of the output terminals.<BR>
<BR>
Sound registers may be set at all times while producing sound.<BR>
<BR>
(Sounds will have a 2.4% higher frequency on Super GB.)<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundchannel1tonesweep"></A><FONT SIZE=+2>&nbsp;Sound Channel 1 - Tone & Sweep</FONT></TD></TR></TABLE><BR>
<B>FF10 - NR10 - Channel 1 Sweep register (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 6-4 - Sweep Time
  Bit 3   - Sweep Increase/Decrease
             0: Addition    (frequency increases)
             1: Subtraction (frequency decreases)
  Bit 2-0 - Number of sweep shift (n: 0-7)
</TD></TR></TABLE>Sweep Time:<BR>
<TABLE><TR><TD><PRE>  000: sweep off - no freq change
  001: 7.8 ms  (1/128Hz)
  010: 15.6 ms (2/128Hz)
  011: 23.4 ms (3/128Hz)
  100: 31.3 ms (4/128Hz)
  101: 39.1 ms (5/128Hz)
  110: 46.9 ms (6/128Hz)
  111: 54.7 ms (7/128Hz)
</TD></TR></TABLE><BR>
The change of frequency (NR13,NR14) at each shift is calculated by the 
following formula where X(0) is initial freq & X(t-1) is last freq:<BR>
<TABLE><TR><TD><PRE>  X(t) = X(t-1) +/- X(t-1)/2^n
</TD></TR></TABLE><BR>
<B>FF11 - NR11 - Channel 1 Sound length/Wave pattern duty (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)
</TD></TR></TABLE>Wave Duty:<BR>
<TABLE><TR><TD><PRE>  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )
</TD></TR></TABLE>Sound Length = (64-t1)*(1/256) seconds<BR>
The Length value is used only if Bit 6 in NR14 is set.<BR>
<BR>
<B>FF12 - NR12 - Channel 1 Volume Envelope (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)
</TD></TR></TABLE>Length of 1 step = n*(1/64) seconds<BR>
<BR>
<B>FF13 - NR13 - Channel 1 Frequency lo (Write Only)<BR>
</B><BR>
Lower 8 bits of 11 bit frequency (x).<BR>
Next 3 bit are in NR14 ($FF14)<BR>
<BR>
<B>FF14 - NR14 - Channel 1 Frequency hi (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR11 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)
</TD></TR></TABLE>Frequency = 131072/(2048-x) Hz<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundchannel2tone"></A><FONT SIZE=+2>&nbsp;Sound Channel 2 - Tone</FONT></TD></TR></TABLE><BR>
This sound channel works exactly as channel 1, except that it doesn't 
have a Tone Envelope/Sweep Register.<BR>
<BR>
<B>FF16 - NR21 - Channel 2 Sound Length/Wave Pattern Duty (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-6 - Wave Pattern Duty (Read/Write)
  Bit 5-0 - Sound length data (Write Only) (t1: 0-63)
</TD></TR></TABLE>Wave Duty:<BR>
<TABLE><TR><TD><PRE>  00: 12.5% ( _-------_-------_------- )
  01: 25%   ( __------__------__------ )
  10: 50%   ( ____----____----____---- ) (normal)
  11: 75%   ( ______--______--______-- )
</TD></TR></TABLE>Sound Length = (64-t1)*(1/256) seconds<BR>
The Length value is used only if Bit 6 in NR24 is set.<BR>
<BR>
<B>FF17 - NR22 - Channel 2 Volume Envelope (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)
</TD></TR></TABLE>Length of 1 step = n*(1/64) seconds<BR>
<BR>
<B>FF18 - NR23 - Channel 2 Frequency lo data (W)<BR>
</B>Frequency's lower 8 bits of 11 bit data (x).<BR>
Next 3 bits are in NR24 ($FF19).<BR>
<BR>
<B>FF19 - NR24 - Channel 2 Frequency hi data (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR21 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)
</TD></TR></TABLE>Frequency = 131072/(2048-x) Hz<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundchannel3waveoutput"></A><FONT SIZE=+2>&nbsp;Sound Channel 3 - Wave Output</FONT></TD></TR></TABLE><BR>
This channel can be used to output digital sound, the length of the 
sample buffer (Wave RAM) is limited to 32 digits. This sound channel can 
be also used to output normal tones when initializing the Wave RAM by a 
square wave. This channel doesn't have a volume envelope register.<BR>
<BR>
<B>FF1A - NR30 - Channel 3 Sound on/off (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7 - Sound Channel 3 Off  (0=Stop, 1=Playback)  (Read/Write)
</TD></TR></TABLE><BR>
<B>FF1B - NR31 - Channel 3 Sound Length<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-0 - Sound length (t1: 0 - 255)
</TD></TR></TABLE>Sound Length = (256-t1)*(1/256) seconds<BR>
This value is used only if Bit 6 in NR34 is set.<BR>
<BR>
<B>FF1C - NR32 - Channel 3 Select output level (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 6-5 - Select output level (Read/Write)
</TD></TR></TABLE>Possible Output levels are:<BR>
<TABLE><TR><TD><PRE>  0: Mute (No sound)
  1: 100% Volume (Produce Wave Pattern RAM Data as it is)
  2:  50% Volume (Produce Wave Pattern RAM data shifted once to the right)
  3:  25% Volume (Produce Wave Pattern RAM data shifted twice to the right)
</TD></TR></TABLE><BR>
<B>FF1D - NR33 - Channel 3 Frequency's lower data (W)<BR>
</B>Lower 8 bits of an 11 bit frequency (x).<BR>
<BR>
<B>FF1E - NR34 - Channel 3 Frequency's higher data (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR31 expires)
  Bit 2-0 - Frequency's higher 3 bits (x) (Write Only)
</TD></TR></TABLE>Frequency  =  4194304/(64*(2048-x)) Hz  =  65536/(2048-x) Hz<BR>
<BR>
<B>FF30-FF3F - Wave Pattern RAM<BR>
</B>Contents - Waveform storage for arbitrary sound data<BR>
<BR>
This storage area holds 32 4-bit samples  that are played back upper 4 
bits first.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundchannel4noise"></A><FONT SIZE=+2>&nbsp;Sound Channel 4 - Noise</FONT></TD></TR></TABLE><BR>
This channel is used to output white noise. This is done by randomly 
switching the amplitude between high and low at a given frequency. 
Depending on the frequency the noise will appear 'harder' or 'softer'.<BR>
<BR>
It is also possible to influence the function of the random generator, 
so the that the output becomes more regular, resulting in a limited 
ability to output Tone instead of Noise.<BR>
<BR>
<B>FF20 - NR41 - Channel 4 Sound Length (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 5-0 - Sound length data (t1: 0-63)
</TD></TR></TABLE>Sound Length = (64-t1)*(1/256) seconds<BR>
The Length value is used only if Bit 6 in NR44 is set.<BR>
<BR>
<B>FF21 - NR42 - Channel 4 Volume Envelope (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7-4 - Initial Volume of envelope (0-0Fh) (0=No Sound)
  Bit 3   - Envelope Direction (0=Decrease, 1=Increase)
  Bit 2-0 - Number of envelope sweep (n: 0-7)
            (If zero, stop envelope operation.)
</TD></TR></TABLE>Length of 1 step = n*(1/64) seconds<BR>
<BR>
<B>FF22 - NR43 - Channel 4 Polynomial Counter (R/W)<BR>
</B>The amplitude is randomly switched between high and low at the given 
frequency. A higher frequency will make the noise to appear 'softer'.<BR>
When Bit 3 is set, the output will become more regular, and some 
frequencies will sound more like Tone than Noise.<BR>
<TABLE><TR><TD><PRE>  Bit 7-4 - Shift Clock Frequency (s)
  Bit 3   - Counter Step/Width (0=15 bits, 1=7 bits)
  Bit 2-0 - Dividing Ratio of Frequencies (r)
</TD></TR></TABLE>Frequency = 524288 Hz / r / 2^(s+1)     ;For r=0 assume r=0.5 instead<BR>
<BR>
<B>FF23 - NR44 - Channel 4 Counter/consecutive; Inital (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7   - Initial (1=Restart Sound)     (Write Only)
  Bit 6   - Counter/consecutive selection (Read/Write)
            (1=Stop output when length in NR41 expires)
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="soundcontrolregisters"></A><FONT SIZE=+2>&nbsp;Sound Control Registers</FONT></TD></TR></TABLE><BR>
<B>FF24 - NR50 - Channel control / ON-OFF / Volume (R/W)<BR>
</B>The volume bits specify the "Master Volume" for Left/Right sound output.<BR>
<TABLE><TR><TD><PRE>  Bit 7   - Output Vin to SO2 terminal (1=Enable)
  Bit 6-4 - SO2 output level (volume)  (0-7)
  Bit 3   - Output Vin to SO1 terminal (1=Enable)
  Bit 2-0 - SO1 output level (volume)  (0-7)
</TD></TR></TABLE>The Vin signal is received from the game cartridge bus, allowing 
external hardware in the cartridge to supply a fifth sound channel, 
additionally to the gameboys internal four channels. As far as I know 
this feature isn't used by any existing games.<BR>
<BR>
<B>FF25 - NR51 - Selection of Sound output terminal (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7 - Output sound 4 to SO2 terminal
  Bit 6 - Output sound 3 to SO2 terminal
  Bit 5 - Output sound 2 to SO2 terminal
  Bit 4 - Output sound 1 to SO2 terminal
  Bit 3 - Output sound 4 to SO1 terminal
  Bit 2 - Output sound 3 to SO1 terminal
  Bit 1 - Output sound 2 to SO1 terminal
  Bit 0 - Output sound 1 to SO1 terminal
</TD></TR></TABLE><BR>
<B>FF26 - NR52 - Sound on/off<BR>
</B>If your GB programs don't use sound then write 00h to this register to 
save 16% or more on GB power consumption. Disabeling the sound 
controller by clearing Bit 7 destroys the contents of all sound 
registers. Also, it is not possible to access any sound registers 
(execpt FF26) while the sound controller is disabled.<BR>
<TABLE><TR><TD><PRE>  Bit 7 - All sound on/off  (0: stop all sound circuits) (Read/Write)
  Bit 3 - Sound 4 ON flag (Read Only)
  Bit 2 - Sound 3 ON flag (Read Only)
  Bit 1 - Sound 2 ON flag (Read Only)
  Bit 0 - Sound 1 ON flag (Read Only)
</TD></TR></TABLE>Bits 0-3 of this register are read only status bits, writing to these 
bits does NOT enable/disable sound. The flags get set when sound output 
is restarted by setting the Initial flag (Bit 7 in NR14-NR44), the flag 
remains set until the sound length has expired (if enabled). A volume 
envelopes which has decreased to zero volume will NOT cause the sound 
flag to go off.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="joypadinput"></A><FONT SIZE=+2>&nbsp;Joypad Input</FONT></TD></TR></TABLE><BR>
<B>FF00 - P1/JOYP - Joypad (R/W)<BR>
</B>The eight gameboy buttons/direction keys are arranged in form of a 2x4 
matrix. Select either button or direction keys by writing to this 
register, then read-out bit 0-3.<BR>
<TABLE><TR><TD><PRE>  Bit 7 - Not used
  Bit 6 - Not used
  Bit 5 - P15 Select Button Keys      (0=Select)
  Bit 4 - P14 Select Direction Keys   (0=Select)
  Bit 3 - P13 Input Down  or Start    (0=Pressed) (Read Only)
  Bit 2 - P12 Input Up    or Select   (0=Pressed) (Read Only)
  Bit 1 - P11 Input Left  or Button B (0=Pressed) (Read Only)
  Bit 0 - P10 Input Right or Button A (0=Pressed) (Read Only)
</TD></TR></TABLE>Note: Most programs are repeatedly reading from this port several times 
(the first reads used as short delay, allowing the inputs to stabilize, 
and only the value from the last read actually used).<BR>
<BR>
<B>Usage in SGB software<BR>
</B>Beside for normal joypad input, SGB games mis-use the joypad register to 
output SGB command packets to the SNES, also, SGB programs may read out 
gamepad states from up to four different joypads which can be connected 
to the SNES.<BR>
See SGB description for details.<BR>
<BR>
<B>INT 60 - Joypad Interrupt<BR>
</B>Joypad interrupt is requested when any of the above Input lines changes 
from High to Low. Generally this should happen when a key becomes 
pressed (provided that the button/direction key is enabled by above 
Bit4/5), however, because of switch bounce, one or more High to Low 
transitions are usually produced both when pressing or releasing a key.<BR>
<BR>
<B>Using the Joypad Interrupt<BR>
</B>It's more or less useless for programmers, even when selecting both 
buttons and direction keys simultaneously it still cannot recognize all 
keystrokes, because in that case a bit might be already held low by a 
button key, and pressing the corresponding direction key would thus 
cause no difference. The only meaningful purpose of the keystroke 
interrupt would be to terminate STOP (low power) standby state.<BR>
Also, the joypad interrupt does not appear to work with CGB and GBA 
hardware (the STOP function can be still terminated by joypad keystrokes 
though).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="serialdatatransferlinkcable"></A><FONT SIZE=+2>&nbsp;Serial Data Transfer (Link Cable)</FONT></TD></TR></TABLE><BR>
<B>FF01 - SB - Serial transfer data (R/W)<BR>
</B>8 Bits of data to be read/written<BR>
<BR>
<B>FF02 - SC - Serial Transfer Control  (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 7 - Transfer Start Flag (0=No Transfer, 1=Start)
  Bit 1 - Clock Speed (0=Normal, 1=Fast) ** CGB Mode Only **
  Bit 0 - Shift Clock (0=External Clock, 1=Internal Clock)
</TD></TR></TABLE>The clock signal specifies the rate at which the eight data bits in SB 
(FF01) are transferred. When the gameboy is communicating with another 
gameboy (or other computer) then either one must supply internal clock, 
and the other one must use external clock.<BR>
<BR>
<B>Internal Clock<BR>
</B>In Non-CGB Mode the gameboy supplies an internal clock of 8192Hz only 
(allowing to transfer about 1 KByte per second). In CGB Mode four 
internal clock rates are available, depending on Bit 1 of the SC 
register, and on whether the CGB Double Speed Mode is used:<BR>
<TABLE><TR><TD><PRE>    8192Hz -  1KB/s - Bit 1 cleared, Normal
   16384Hz -  2KB/s - Bit 1 cleared, Double Speed Mode
  262144Hz - 32KB/s - Bit 1 set,     Normal
  524288Hz - 64KB/s - Bit 1 set,     Double Speed Mode
</TD></TR></TABLE><BR>
<B>External Clock<BR>
</B>The external clock is typically supplied by another gameboy, but might 
be supplied by another computer (for example if connected to a PCs 
parallel port), in that case the external clock may have any speed. Even 
the old/monochrome gameboy is reported to recognizes external clocks of 
up to 500KHz. And there is no limitiation into the other direction - 
even when suppling an external clock speed of "1 bit per month", then 
the gameboy will still eagerly wait for the next bit(s) to be 
transferred. It isn't required that the clock pulses are sent at an 
regular interval either.<BR>
<BR>
<B>Timeouts<BR>
</B>When using external clock then the transfer will not complete until the 
last bit is received. In case that the second gameboy isn't supplying a 
clock signal, if it gets turned off, or if there is no second gameboy 
connected at all) then transfer will never complete. For this reason the 
transfer procedure should use a timeout counter, and abort the 
communication if no response has been received during the timeout 
interval.<BR>
<BR>
<B>Delays and Synchronization<BR>
</B>The gameboy that is using internal clock should always execute a small 
delay between each transfer, in order to ensure that the opponent 
gameboy has enough time to prepare itself for the next transfer, ie. the 
gameboy with external clock must have set its transfer start bit before 
the gameboy with internal clock starts the transfer. Alternately, the 
two gameboys could switch between internal and external clock for each 
transferred byte to ensure synchronization.<BR>
<BR>
Transfer is initiated by setting the Transfer Start Flag. This bit is 
automatically set to 0 at the end of Transfer. Reading this bit can be 
used to determine if the transfer is still active.<BR>
<BR>
<B>INT 58 - Serial Interrupt<BR>
</B>When the transfer has completed (ie. after sending/receiving 8 bits, if 
any) then an interrupt is requested by setting Bit 3 of the IF Register 
(FF0F). When that interrupt is enabled, then the Serial Interrupt vector 
at 0058 is called.<BR>
<BR>
<B>XXXXXX...<BR>
</B><BR>
Transmitting and receiving serial data is done simultaneously. The 
received data is automatically stored in SB.<BR>
<BR>
The serial I/O port on the Gameboy is a very simple setup and is crude 
compared to standard RS-232 (IBM-PC) or RS-485 (Macintosh) serial ports. 
There are no start or stop bits.<BR>
<BR>
During a transfer, a byte is shifted in at the same time that a byte is 
shifted out. The rate of the shift is determined by whether the clock 
source is internal or external.<BR>
The most significant bit is shifted in and out first.<BR>
<BR>
When the internal clock is selected, it drives the clock pin on the game 
link port and it stays high when not used. During a transfer it will go 
low eight times to clock in/out each bit.<BR>
<BR>
The state of the last bit shifted out determines the state of the output 
line until another transfer takes place.<BR>
<BR>
If a serial transfer with internal clock is performed and no external 
GameBoy is present, a value of $FF will be received in the transfer.<BR>
<BR>
The following code causes $75 to be shifted out the serial port and a 
byte to be shifted into $FF01:<BR>
<BR>
<TABLE><TR><TD><PRE>    ld   a,$75
    ld  ($FF01),a
    ld   a,$81
    ld  ($FF02),a
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="timeranddividerregisters"></A><FONT SIZE=+2>&nbsp;定时与分频寄存器</FONT></TD></TR></TABLE><BR>
<B>FF04 - DIV - 分频寄存器 (读/写)<BR>
</B>该寄存器以16384Hz为单位而递增（SGB上约为16779Hz）。
    在CGB双倍速模式下，它以两倍速递增，即32768Hz。
    向该寄存器写入任意值都会将其重置为00h。<BR>
<BR>
<B>FF05 - TIMA - 定时计数器 (读/写)<BR>
</B>该寄存器以TAC寄存器（$FF07）指定的时钟频率递增。
    当发生溢出时（递增到比FFh还要大），它将重置为TMA（FF06）指定的值，并请求一个如后文描述的中断。<BR>
<BR>
<B>FF06 - TMA - 定时器模除(读/写)<BR>
</B>当TIMA溢出时，该数据将被载入。（载入到TIMA中，译注）<BR>
<BR>
<B>FF07 - TAC - 定时器控制 (R/W)<BR>
</B><TABLE><TR><TD><PRE>  比特位 2    - 定时器停止  (0=停止, 1=开始)
  比特位 1-0 - 输入时钟选择
             00:   4096 Hz    (~4194 Hz SGB)
             01: 262144 Hz  (~268400 Hz SGB)
             10:  65536 Hz   (~67110 Hz SGB)
             11:  16384 Hz   (~16780 Hz SGB)
</TD></TR></TABLE><BR>
<B>INT 50 - 定时器中断<BR>
</B>当定时器溢出时， （如，TIMA递增到比FFh还要大），就会通过将IF寄存器（FF0F）的比特位2置为1请求一个中断。若该中断已启用，那么CPU将调用位于0050h的定时器中断向量来执行中断程序。<BR>
<BR>
<B>注意<BR>
</B>上述定时器指的是Gameboy内建的定时器。它和MBC3型卡带的电池驱动真实时钟（RTC）无关。实际上，RTC是一个完全不同的东西，将会在存储容组控制器（MBC）一章中讲到。（bank暂译为容组，译注）<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="interrupts"></A><FONT SIZE=+2>&nbsp;Interrupts</FONT></TD></TR></TABLE><BR>
<B>IME - Interrupt Master Enable Flag (Write Only)<BR>
</B><TABLE><TR><TD><PRE>  0 - Disable all Interrupts
  1 - Enable all Interrupts that are enabled in IE Register (FFFF)
</TD></TR></TABLE>The IME flag is used to disable all interrupts, overriding any enabled 
bits in the IE Register. It isn't possible to access the IME flag by 
using a I/O address, instead IME is accessed directly from the CPU, by 
the following opcodes/operations:<BR>
<TABLE><TR><TD><PRE>  EI     ;Enable Interrupts  (ie. IME=1)
  DI     ;Disable Interrupts (ie. IME=0)
  RETI   ;Enable Ints & Return (same as the opcode combination EI, RET)
  &lt;INT&gt;  ;Disable Ints & Call to Interrupt Vector
</TD></TR></TABLE>Whereas &lt;INT&gt; means the operation which is automatically executed by the 
CPU when it executes an interrupt.<BR>
<BR>
<B>FFFF - IE - Interrupt Enable (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 0: V-Blank  Interrupt Enable  (INT 40h)  (1=Enable)
  Bit 1: LCD STAT Interrupt Enable  (INT 48h)  (1=Enable)
  Bit 2: Timer    Interrupt Enable  (INT 50h)  (1=Enable)
  Bit 3: Serial   Interrupt Enable  (INT 58h)  (1=Enable)
  Bit 4: Joypad   Interrupt Enable  (INT 60h)  (1=Enable)
</TD></TR></TABLE><BR>
<B>FF0F - IF - Interrupt Flag (R/W)<BR>
</B><TABLE><TR><TD><PRE>  Bit 0: V-Blank  Interrupt Request (INT 40h)  (1=Request)
  Bit 1: LCD STAT Interrupt Request (INT 48h)  (1=Request)
  Bit 2: Timer    Interrupt Request (INT 50h)  (1=Request)
  Bit 3: Serial   Interrupt Request (INT 58h)  (1=Request)
  Bit 4: Joypad   Interrupt Request (INT 60h)  (1=Request)
</TD></TR></TABLE>When an interrupt signal changes from low to high, then the 
corresponding bit in the IF register becomes set. For example, Bit 0 
becomes set when the LCD controller enters into the V-Blank period.<BR>
<BR>
<B>Interrupt Requests<BR>
</B>Any set bits in the IF register are only &lt;requesting&gt; an interrupt to be 
executed. The actual &lt;execution&gt; happens only if both the IME flag, and 
the corresponding bit in the IE register are set, otherwise the 
interrupt 'waits' until both IME and IE allow its execution.<BR>
<BR>
<B>Interrupt Execution<BR>
</B>When an interrupt gets executed, the corresponding bit in the IF 
register becomes automatically reset by the CPU, and the IME flag 
becomes cleared (disabeling any further interrupts until the program 
re-enables the interrupts, typically by using the RETI instruction), and 
the corresponding Interrupt Vector (that are the addresses in range 
0040h-0060h, as shown in IE and IF register decriptions above) becomes 
called.<BR>
<BR>
<B>Manually Requesting/Discarding Interrupts<BR>
</B>As the CPU automatically sets and cleares the bits in the IF register it 
is usually not required to write to the IF register. However, the user 
may still do that in order to manually request (or discard) interrupts. 
As for real interrupts, a manually requested interrupt isn't executed 
unless/until IME and IE allow its execution.<BR>
<BR>
<B>Interrupt Priorities<BR>
</B>In the following three situations it might happen that more than 1 bit 
in the IF register are set, requesting more than one interrupt at once:<BR>
<TABLE><TR><TD><PRE>  1) More than one interrupt signal changed from Low
     to High at the same time.
  2) Several interrupts have been requested during a
     time in which IME/IE didn't allow these interrupts
     to be executed directly.
  3) The user has written a value with several "1" bits
     (for example 1Fh) to the IF register.
</TD></TR></TABLE>Provided that IME and IE allow the execution of more than one of the 
requested interrupts, then the interrupt with the highest priority 
becomes executed first. The priorities are ordered as the bits in the IE 
and IF registers, Bit 0 (V-Blank) having the highest priority, and Bit 4 
(Joypad) having the lowest priority.<BR>
<BR>
<B>Nested Interrupts<BR>
</B>The CPU automatically disables all other interrupts by setting IME=0 
when it executes an interrupt. Usually IME remains zero until the 
interrupt procedure returns (and sets IME=1 by the RETI instruction). 
However, if you want any other interrupts of lower or higher (or same) 
priority to be allowed to be executed from inside of the interrupt 
procedure, then you can place an EI instruction into the interrupt 
procedure.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="cgbregisters"></A><FONT SIZE=+2>&nbsp;CGB Registers</FONT></TD></TR></TABLE><BR>
<B>Forward<BR>
</B>This chapter describes only CGB (Color Gameboy) registers that didn't 
fit into normal categories - most CGB registers are described in the 
chapter about Video Display (Color Palettes, VRAM Bank, VRAM DMA 
Transfers, and changed meaning of Bit 0 of LCDC Control register). Also, 
a changed bit is noted in the chapter about the Serial/Link port.<BR>
<BR>
<B>Unlocking CGB functions<BR>
</B>When using any CGB registers (including those in the Video/Link 
chapters), you must first unlock CGB features by changing byte 0143h in 
the cartridge header. Typically use a value of 80h for games which 
support both CGB and monochrome gameboys, and C0h for games which work 
on CGBs only. Otherwise, the CGB will operate in monochrome "Non CGB" 
compatibility mode.<BR>
<BR>
<B>Detecting CGB (and GBA) functions<BR>
</B>CGB hardware can be detected by examing the CPU accumulator (A-register) 
directly after startup. A value of 11h indicates CGB (or GBA) hardware, 
if so, CGB functions can be used (if unlocked, see above).<BR>
When A=11h, you may also examine Bit 0 of the CPUs B-Register to 
separate between CGB (bit cleared) and GBA (bit set), by that detection 
it is possible to use 'repaired' color palette data matching for GBA 
displays.<BR>
<BR>
<B>FF4D - KEY1 - CGB Mode Only - Prepare Speed Switch<BR>
</B><TABLE><TR><TD><PRE>  Bit 7: Current Speed     (0=Normal, 1=Double) (Read Only)
  Bit 0: Prepare Speed Switch (0=No, 1=Prepare) (Read/Write)
</TD></TR></TABLE>This register is used to prepare the gameboy to switch between CGB 
Double Speed Mode and Normal Speed Mode. The actual speed switch is 
performed by executing a STOP command after Bit 0 has been set. After 
that Bit 0 will be cleared automatically, and the gameboy will operate 
at the 'other' speed. The recommended speed switching procedure in 
pseudo code would be:<BR>
<TABLE><TR><TD><PRE>  IF KEY1_BIT7 &lt;&gt; DESIRED_SPEED THEN
    IE=00H       ;(FFFF)=00h
    JOYP=30H     ;(FF00)=30h
    KEY1=01H     ;(FF4D)=01h
    STOP         ;STOP
  ENDIF
</TD></TR></TABLE>The CGB is operating in Normal Speed Mode when it is turned on. Note 
that using the Double Speed Mode increases the power consumption, it 
would be recommended to use Single Speed whenever possible. However, the 
display will flicker (white) for a moment during speed switches, so this 
cannot be done permanentely.<BR>
In Double Speed Mode the following will operate twice as fast as normal:<BR>
<TABLE><TR><TD><PRE>  The CPU (2.10 MHz, 1 Cycle = approx. 0.5us)
  Timer and Divider Registers
  Serial Port (Link Cable)
  DMA Transfer to OAM
</TD></TR></TABLE>And the following will keep operating as usual:<BR>
<TABLE><TR><TD><PRE>  LCD Video Controller
  HDMA Transfer to VRAM
  All Sound Timings and Frequencies
</TD></TR></TABLE><BR>
<B>FF56 - RP - CGB Mode Only - Infrared Communications Port<BR>
</B>This register allows to input and output data through the CGBs built-in 
Infrared Port. When reading data, bit 6 and 7 must be set (and obviously 
Bit 0 must be cleared - if you don't want to receive your own gameboys 
IR signal). After sending or receiving data you should reset the 
register to 00h to reduce battery power consumption again.<BR>
<TABLE><TR><TD><PRE>  Bit 0:   Write Data   (0=LED Off, 1=LED On)             (Read/Write)
  Bit 1:   Read Data    (0=Receiving IR Signal, 1=Normal) (Read Only)
  Bit 6-7: Data Read Enable (0=Disable, 3=Enable)         (Read/Write)
</TD></TR></TABLE>Note that the receiver will adapt itself to the normal level of IR 
pollution in the air, so if you would send a LED ON signal for a longer 
period, then the receiver would treat that as normal (=OFF) after a 
while. For example, a Philips TV Remote Control sends a series of 32 LED 
ON/OFF pulses (length 10us ON, 17.5us OFF each) instead of a permanent 
880us LED ON signal.<BR>
Even though being generally CGB compatible, the GBA does not include an 
infra-red port.<BR>
<BR>
<B>FF70 - SVBK - CGB Mode Only - WRAM Bank<BR>
</B>In CGB Mode 32 KBytes internal RAM are available. This memory is divided 
into 8 banks of 4 KBytes each. Bank 0 is always available in memory at 
C000-CFFF, Bank 1-7 can be selected into the address space at D000-DFFF.<BR>
<TABLE><TR><TD><PRE>  Bit 0-2  Select WRAM Bank (Read/Write)
</TD></TR></TABLE>Writing a value of 01h-07h will select Bank 1-7, writing a value of 00h 
will select Bank 1 either.<BR>
<BR>
<B>FF6C - Undocumented (FEh) - Bit 0   (Read/Write) - CGB Mode Only<BR>
FF72 - Undocumented (00h) - Bit 0-7 (Read/Write)<BR>
FF73 - Undocumented (00h) - Bit 0-7 (Read/Write)<BR>
FF74 - Undocumented (00h) - Bit 0-7 (Read/Write) - CGB Mode Only<BR>
FF75 - Undocumented (8Fh) - Bit 4-6 (Read/Write)<BR>
FF76 - Undocumented (00h) - Always 00h (Read Only)<BR>
FF77 - Undocumented (00h) - Always 00h (Read Only)<BR>
</B>These are undocumented CGB Registers. The numbers in brackets () 
indicate the initial values. Purpose of these registers is unknown (if 
any). Registers FF6C and FF74 are always FFh if the CGB is in Non CGB 
Mode.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbfunctions"></A><FONT SIZE=+2>&nbsp;SGB Functions</FONT></TD></TR></TABLE><BR>
<B>General Information<BR>
</B><A HREF="#sgbdescription">SGB Description</A><BR>
<A HREF="#sgbunlockinganddetectingsgbfunctions">SGB Unlocking and Detecting SGB Functions</A><BR>
<A HREF="#sgbcommandpackettransfers">SGB Command Packet Transfers</A><BR>
<A HREF="#sgbvramtransfers">SGB VRAM Transfers</A><BR>
<A HREF="#sgbcommandsummary">SGB Command Summary</A><BR>
<A HREF="#sgbcolorpalettesoverview">SGB Color Palettes Overview</A><BR>
<BR>
<B>SGB Commands<BR>
</B><A HREF="#sgbpalettecommands">SGB Palette Commands</A><BR>
<A HREF="#sgbcolorattributecommands">SGB Color Attribute Commands</A><BR>
<A HREF="#sgbsoundfunctions">SGB Sound Functions</A><BR>
<A HREF="#sgbsystemcontrolcommands">SGB System Control Commands</A><BR>
<A HREF="#sgbmultiplayercommand">SGB Multiplayer Command</A><BR>
<A HREF="#sgbborderandobjcommands">SGB Border and OBJ Commands</A><BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbdescription"></A><FONT SIZE=+2>&nbsp;SGB Description</FONT></TD></TR></TABLE><BR>
<B>General Description<BR>
</B>Basically, the SGB (Super Gameboy) is an adapter cartridge that allows 
to play gameboy games on a SNES (Super Nintendo Entertainment System) 
gaming console. In detail, you plug the gameboy cartridge into the SGB 
cartridge, then plug the SGB cartridge into the SNES, and then connect 
the SNES to your TV Set. In result, games can be played and viewed on 
the TV Set, and are controlled by using the SNES joypad(s).<BR>
<BR>
<B>More Technical Description<BR>
</B>The SGB cartridge just contains a normal gameboy CPU and normal gameboy 
video controller. Normally the video signal from this controller would 
be sent to the LCD screen, however, in this special case the SNES read 
out the video signal and displays it on the TV set by using a special 
SNES BIOS ROM which is located in the SGB cartridge. Also, normal 
gameboy sound output is forwared to the SNES and output to the TV Set, 
vice versa, joypad input is forwared from the SNES controller(s) to the 
gameboy joypad inputs.<BR>
<BR>
<B>Normal Monochrome Games<BR>
</B>Any gameboy games which have been designed for normal monochrome 
handheld gameboys will work with the SGB hardware as well. The SGB will 
apply a four color palette to these games by replacing the normal four 
grayshades. The 160x144 pixel gamescreen is displayed in the middle of 
the 256x224 pixel SNES screen (the unused area is filled by a screen 
border bitmap). The user may access built-in menues, allowing to change 
color palette data, to select between several pre-defined borders, etc.<BR>
<BR>
Games that have been designed to support SGB functions may also access 
the following additional features:<BR>
<BR>
<B>Colorized Game Screen<BR>
</B>There's limited ability to colorize the gamescreen by assigning custom 
color palettes to each 20x18 display characters, however, this works 
mainly for static display data such like title screens or status bars, 
the 20x18 color attribute map is non-scrollable, and it is not possible 
to assign separate colors to moveable foreground sprites (OBJs), so that 
animated screen regions will be typically restricted to using a single 
palette of four colors only.<BR>
<BR>
<B>SNES Foreground Sprites<BR>
</B>Up to 24 foreground sprites (OBJs) of 8x8 or 16x16 pixels, 16 colors can 
be displayed. When replacing (or just overlaying) the normal gameboy 
OBJs by SNES OBJs it'd be thus possible to display OBJs with other 
colors than normal background area. This method doesn't appear to be 
very popular, even though it appears to be quite easy to implement, 
however, the bottommost character line of the gamescreen will be masked 
out because this area is used to transfer OAM data to the SNES.<BR>
<BR>
<B>The SGB Border<BR>
</B>The possibly most popular and most impressive feature is to replace the 
default SGB screen border by a custom bitmap which is stored in the game 
cartridge.<BR>
<BR>
<B>Multiple Joypads<BR>
</B>Up to four joypads can be conected to the SNES, and SGB software may 
read-out each of these joypads separately, allowing up to four players 
to play the same game simultaneously. Unlike for multiplayer handheld 
games, this requires only one game cartridge and only one SGB/SNES, and 
no link cables are required, the downside is that all players must share 
the same display screen.<BR>
<BR>
<B>Sound Functions<BR>
</B>Beside for normal gameboy sound, a number of digital sound effects is 
pre-defined in the SNES BIOS, these effects may be accessed quite 
easily. Programmers whom are familiar with SNES sounds may also access 
the SNES sound chip, or use the SNES MIDI engine directly in order to 
produce other sound effects or music.<BR>
<BR>
<B>Taking Control of the SNES CPU<BR>
</B>Finally, it is possible to write program code or data into SNES memory, 
and to execute such program code by using the SNES CPU.<BR>
<BR>
<B>SGB System Clock<BR>
</B>Because the SGB is synchronized to the SNES CPU, the gameboy system 
clock is directly chained to the SNES system clock. In result, the 
gameboy CPU, video controller, timers, and sound frequencies will be all 
operated approx 2.4% faster as by normal gameboys.<BR>
Basically, this should be no problem, and the game will just run a 
little bit faster. However sensitive musicians may notice that sound 
frequencies are a bit too high, programs that support SGB functions may 
avoid this effect by reducing frequencies of gameboy sounds when having 
detected SGB hardware.<BR>
Also, I think that I've heard that SNES models which use a 50Hz display 
refresh rate (rather than 60Hz) are resulting in respectively slower 
SGB/gameboy timings ???<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbunlockinganddetectingsgbfunctions"></A><FONT SIZE=+2>&nbsp;SGB Unlocking and Detecting SGB Functions</FONT></TD></TR></TABLE><BR>
<B>Cartridge Header<BR>
</B>SGB games are required to have a cartridge header with Nintendo and 
proper checksum just as normal gameboy games. Also, two special entries 
must be set in order to unlock SGB functions:<BR>
<TABLE><TR><TD><PRE>  146h - SGB Flag - Must be set to 03h for SGB games
  14Bh - Old Licensee Code - Must be set 33h for SGB games
</TD></TR></TABLE>When these entries aren't set, the game will still work just like all 
'monochrome' gameboy games, but it cannot access any of the special SGB 
functions.<BR>
<BR>
<B>Detecting SGB hardware<BR>
</B>The recommended detection method is to send a MLT_REQ command which 
enables two (or four) joypads. A normal handheld gameboy will ignore 
this command, a SGB will now return incrementing joypad IDs each time 
when deselecting keyboard lines (see MLT_REQ description for details).<BR>
Now read-out joypad state/IDs several times, and if the ID-numbers are 
changing, then it is a SGB (a normal gameboy would typically always 
return 0Fh as ID). Finally, when not intending to use more than one 
joypad, send another MLT_REQ command in order to re-disable the 
multi-controller mode.<BR>
Detection works regardless of whether and how many joypads are 
physically connected to the SNES. However, detection works only when 
having unlocked SGB functions in the cartridge header, as described 
above. <BR>
<BR>
<B>Separating between SGB and SGB2<BR>
</B>It is also possible to separate between SGB and SGB2 models by examining 
the inital value of the accumulator (A-register) directly after startup.<BR>
<TABLE><TR><TD><PRE>  01h  SGB or Normal Gameboy (DMG)
  FFh  SGB2 or Pocket Gameboy
  11h  CGB or GBA
</TD></TR></TABLE>Because values 01h and FFh are shared for both handhelds and SGBs, it is 
still required to use the above MLT_REQ detection procedure. As far as I 
know the SGB2 doesn't have any extra features which'd require separate 
SGB2 detection except for curiosity purposes, for example, the game 
"Tetris DX" chooses to display an alternate SGB border on SGB2s.<BR>
<BR>
Reportedly, some SGB models include link ports (just like handheld 
gameboy) (my own SGB does not have such an port), possibly this feature 
is available in SGB2-type models only ???<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbcommandpackettransfers"></A><FONT SIZE=+2>&nbsp;SGB Command Packet Transfers</FONT></TD></TR></TABLE><BR>
Command packets (aka Register Files) are transferred from the gameboy to 
the SNES by using P14 and P15 output lines of the JOYPAD register 
(FF00h), these lines are normally used to select the two rows in the 
gameboy keyboard matrix (which still works).<BR>
<BR>
<B>Transferring Bits<BR>
</B>A command packet transfer must be initiated by setting both P14 and P15 
to LOW, this will reset and start the SNES packet receiving program. 
Data is then transferred (LSB first), setting P14=LOW will indicate a 
"0" bit, and setting P15=LOW will indicate a "1" bit. For example:<BR>
<TABLE><TR><TD><PRE>       RESET 0   0   1   1   0   1   0
  P14  --_---_---_-----------_-------_--...
  P15  --_-----------_---_-------_------...
</TD></TR></TABLE>Data and reset pulses must be kept LOW for at least 5us. P14 and P15 
must be kept both HIGH for at least 15us between any pulses.<BR>
Obviously, it'd be no good idea to access the JOYPAD register during the 
transfer, for example, in case that your VBlank interrupt procedure 
reads-out joypad states each frame, be sure to disable that interrupt 
during the transfer (or disable only the joypad procedure by using a 
software flag).<BR>
<BR>
<B>Transferring Packets<BR>
</B>Each packet is invoked by a RESET pulse, then 128 bits of data are 
transferred (16 bytes, LSB of first byte first), and finally, a "0"-bit 
must be transferred as stop bit. The structure of normal packets is:<BR>
<TABLE><TR><TD><PRE>   1 PULSE Reset
   1 BYTE  Command Code*8+Length
  15 BYTES Parameter Data
   1 BIT   Stop Bit (0)
</TD></TR></TABLE>The above 'Length' indicates the total number of packets (1-7, including 
the first packet) which will be sent, ie. if more than 15 parameter 
bytes are used, then further packet(s) will follow, as such:<BR>
<TABLE><TR><TD><PRE>   1 PULSE Reset
  16 BYTES Parameter Data
   1 BIT   Stop Bit (0)
</TD></TR></TABLE>By using all 7 packets, up to 111 data bytes (15+16*6) may be sent.<BR>
Unused bytes at the end of the last packet must be set to zero.<BR>
A 60ms (4 frames) delay should be invoked between each packet transfer.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbvramtransfers"></A><FONT SIZE=+2>&nbsp;SGB VRAM Transfers</FONT></TD></TR></TABLE><BR>
<B>Overview<BR>
</B>Beside for the packet transfer method, larger data blocks of 4KBytes can 
be transferred by using the video signal. These transfers are invoked by 
first sending one of the commands with the ending _TRN (by using normal 
packet transfer), the 4K data block is then read-out by the SNES from 
gameboy display memory during the next frame.<BR>
<BR>
<B>Transfer Data<BR>
</B>Normally, transfer data should be stored at 8000h-8FFFh in gameboy VRAM,<BR>
even though the SNES receives the data in from display scanlines, it 
will automatically re-produce the same ordering of bits and bytes, as 
being originally stored at 8000h-8FFFh in gameboy memory.<BR>
<BR>
<B>Preparing the Display<BR>
</B>The above method works only when recursing the following things: BG Map 
must display unsigned characters 00h-FFh on the screen; 00h..13h in 
first line, 14h..27h in next line, etc. The gameboy display must be 
enabled, the display may not be scrolled, OBJ sprites should not overlap 
the background tiles, the BGP palette register must be set to E4h.<BR>
<BR>
<B>Transfer Time<BR>
</B>Note that the transfer data should be prepared in VRAM &lt;before&gt; sending 
the transfer command packet. The actual transfer starts at the beginning 
of the next frame after the command has been sent, and the transfer ends 
at the end of the 5th frame after the command has been sent (not 
counting the frame in which the command has been sent).<BR>
<BR>
<B>Avoiding Screen Garbage<BR>
</B>The display will contain 'garbage' during the transfer, this dirt-effect 
can be avoided by freezing the screen (in the state which has been 
displayed before the transfer) by using the MASK_EN command.<BR>
Of course, this works only when actually executing the game on a SGB 
(and not on normal handheld gameboys), it'd be thus required to detect 
the presence of SGB hardware before blindly sending VRAM data.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbcommandsummary"></A><FONT SIZE=+2>&nbsp;SGB Command Summary</FONT></TD></TR></TABLE><BR>
<B>SGB System Command Table<BR>
</B><TABLE><TR><TD><PRE>  Code Name      Expl.
  00   PAL01     Set SGB Palette 0,1 Data
  01   PAL23     Set SGB Palette 2,3 Data
  02   PAL03     Set SGB Palette 0,3 Data
  03   PAL12     Set SGB Palette 1,2 Data
  04   ATTR_BLK  "Block" Area Designation Mode
  05   ATTR_LIN  "Line" Area Designation Mode
  06   ATTR_DIV  "Divide" Area Designation Mode
  07   ATTR_CHR  "1CHR" Area Designation Mode
  08   SOUND     Sound On/Off
  09   SOU_TRN   Transfer Sound PRG/DATA
  0A   PAL_SET   Set SGB Palette Indirect
  0B   PAL_TRN   Set System Color Palette Data
  0C   ATRC_EN   Enable/disable Attraction Mode
  0D   TEST_EN   Speed Function
  0E   ICON_EN   SGB Function
  0F   DATA_SND  SUPER NES WRAM Transfer 1
  10   DATA_TRN  SUPER NES WRAM Transfer 2
  11   MLT_REG   Controller 2 Request
  12   JUMP      Set SNES Program Counter
  13   CHR_TRN   Transfer Character Font Data
  14   PCT_TRN   Set Screen Data Color Data
  15   ATTR_TRN  Set Attribute from ATF
  16   ATTR_SET  Set Data to ATF
  17   MASK_EN   Game Boy Window Mask
  18   OBJ_TRN   Super NES OBJ Mode
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbcolorpalettesoverview"></A><FONT SIZE=+2>&nbsp;SGB Color Palettes Overview</FONT></TD></TR></TABLE><BR>
<B>Available SNES Palettes<BR>
</B>The SGB/SNES provides 8 palettes of 16 colors each, each color may be 
defined out of a selection of 34768 colors (15 bit). Palettes 0-3 are 
used to colorize the gamescreen, only the first four colors of each of 
these palettes are used. Palettes 4-7 are used for the SGB Border, all 
16 colors of each of these palettes may be used.<BR>
<BR>
<B>Color 0 Restriction<BR>
</B>Color 0 of each of the eight palettes is transparent, causing the 
backdrop color to be displayed instead. The backdrop color is typically 
defined by the most recently color being assigned to Color 0 (regardless 
of the palette number being used for that operation).<BR>
Effectively, gamescreen palettes can have only three custom colors each, 
and SGB border palettes only 15 colors each, additionally, color 0 can 
be used for for all palettes, which will then all share the same color 
though.<BR>
<BR>
<B>Translation of Grayshades into Colors<BR>
</B>Because the SGB/SNES reads out the gameboy video controllers display 
signal, it translates the different grayshades from the signal into SNES 
colors as such:<BR>
<TABLE><TR><TD><PRE>  White       --&gt;  Color 0
  Light Gray  --&gt;  Color 1
  Dark Gray   --&gt;  Color 2
  Black       --&gt;  Color 3
</TD></TR></TABLE>Note that gameboy colors 0-3 are assigned to user-selectable grayshades 
by the gameboys BGP, OBP1, and OBP2 registers. There is thus no fixed 
relationship between gameboy colors 0-3 and SNES colors 0-3.<BR>
<BR>
<B>Using Gameboy BGP/OBP Registers<BR>
</B>A direct translation of color 0-3 into color 0-3 may be produced by 
setting BGP/OBP registers to a value of 0E4h each. However, in case that 
your program uses black background for example, then you may internally 
assign background as "White" at the gameboy side by BGP/OBP registers 
(which is then interpreted as SNES color 0, which is shared for all SNES 
palettes). The advantage is that you may define Color 0 as Black at the 
SNES side, and may assign custom colors for Colors 1-3 of each SNES 
palette.<BR>
<BR>
<B>System Color Palette Memory<BR>
</B>Beside for the actually visible palettes, up to 512 palettes of 4 colors 
each may be defined in SNES RAM. Basically, this is completely 
irrelevant because the palettes are just stored in RAM whithout any 
relationship to the displayed picture, anyways, these pre-defined colors 
may be transferred to actually visible palettes slightly faster as when 
transferring palette data by separate command packets.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbpalettecommands"></A><FONT SIZE=+2>&nbsp;SGB Palette Commands</FONT></TD></TR></TABLE><BR>
<B>SGB Command 00h - PAL01<BR>
</B>Transmit color data for SGB palette 0, color 0-3, and for SGB palette 1, 
color 1-3 (without separate color 0).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=01h)
  1-E   Color Data for 7 colors of 2 bytes (16bit) each:
          Bit 0-4   - Red Intensity   (0-31)
          Bit 5-9   - Green Intensity (0-31)
          Bit 10-14 - Blue Intensity  (0-31)
          Bit 15    - Not used (zero)
  F     Not used (00h)
</TD></TR></TABLE>The value transferred as color 0 will be applied for all eight palettes.<BR>
<BR>
<B>SGB Command 01h - PAL23<BR>
</B>Same as above PAL01, but for Palettes 2 and 3 respectively.<BR>
<BR>
<B>SGB Command 02h - PAL03<BR>
</B>Same as above PAL01, but for Palettes 0 and 3 respectively.<BR>
<BR>
<B>SGB Command 03h - PAL12<BR>
</B>Same as above PAL01, but for Palettes 1 and 2 respectively.<BR>
<BR>
<B>SGB Command 0Ah - PAL_SET<BR>
</B>Used to copy pre-defined palette data from SGB system color palette to 
actual SGB palette.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-2   System Palette number for SGB Color Palette 0 (0-511)
  3-4   System Palette number for SGB Color Palette 1 (0-511)
  5-6   System Palette number for SGB Color Palette 2 (0-511)
  7-8   System Palette number for SGB Color Palette 3 (0-511)
  9     Attribute File
          Bit 0-5 - Attribute File Number (00h-2Ch) (Used only if Bit7=1)
          Bit 6   - Cancel Mask           (0=No change, 1=Yes)
          Bit 7   - Use Attribute File    (0=No, 1=Apply above ATF Number)
  A-F   Not used (zero)
</TD></TR></TABLE>Before using this function, System Palette data should be initialized by 
PAL_TRN command, and (when used) Attribute File data should be 
initialized by ATTR_TRN.<BR>
<BR>
<B>SGB Command 0Bh - PAL_TRN<BR>
</B>Used to initialize SGB system color palettes in SNES RAM.<BR>
System color palette memory contains 512 pre-defined palettes, these 
palettes do not directly affect the display, however, the PAL_SET 
command may be later used to transfer four of these 'logical' palettes 
to actual visible 'physical' SGB palettes. Also, the OBJ_TRN function 
will use groups of 4 System Color Palettes (4*4 colors) for SNES OBJ 
palettes (16 colors).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)
</TD></TR></TABLE>The palette data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000-FFF  Data for System Color Palette 0-511
</TD></TR></TABLE>Each Palette consists of four 16bit-color definitions (8 bytes).<BR>
Note: The data is stored at 3000h-3FFFh in SNES memory.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbcolorattributecommands"></A><FONT SIZE=+2>&nbsp;SGB Color Attribute Commands</FONT></TD></TR></TABLE><BR>
<B>SGB Command 04h - ATTR_BLK<BR>
</B>Used to specify color attributes for the inside or outside of one or 
more rectangular screen regions.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..12h)
  2-7   Data Set #1
          Byte 0 - Control Code (0-7)
            Bit 0 - Change Colors inside of surrounded area     (1=Yes)
            Bit 1 - Change Colors of surrounding character line (1=Yes)
            Bit 2 - Change Colors outside of surrounded area    (1=Yes)
            Bit 3-7 - Not used (zero)
            Exception: When changing only the Inside or Outside, then the
            Surrounding line becomes automatically changed to same color.
          Byte 1 - Color Palette Designation
            Bit 0-1 - Palette Number for inside of surrounded area
            Bit 2-3 - Palette Number for surrounding character line
            Bit 4-5 - Palette Number for outside of surrounded area
            Bit 6-7 - Not used (zero)
          Data Set Byte 2 - Coordinate X1 (left)
          Data Set Byte 3 - Coordinate Y1 (upper)
          Data Set Byte 4 - Coordinate X2 (right)
          Data Set Byte 5 - Coordinate Y2 (lower)
            Specifies the coordinates of the surrounding rectangle.
  8-D   Data Set #2 (if any)
  E-F   Data Set #3 (continued at 0-3 in next packet) (if any)
</TD></TR></TABLE>When sending three or more data sets, data is continued in further 
packet(s). Unused bytes at the end of the last packet should be set to 
zero. The format of the separate Data Sets is described below.<BR>
<BR>
<B>SGB Command 05h - ATTR_LIN<BR>
</B>Used to specify color attributes of one or more horizontal or vertical 
character lines.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (length=1..7)
  1     Number of Data Sets (01h..6Eh) (one byte each)
  2     Data Set #1
          Bit 0-4 - Line Number    (X- or Y-coordinate, depending on bit 7)
          Bit 5-6 - Palette Number (0-3)
          Bit 7   - H/V Mode Bit   (0=Vertical line, 1=Horizontal Line)
  3     Data Set #2 (if any)
  4     Data Set #3 (if any)
  etc.
</TD></TR></TABLE>When sending 15 or more data sets, data is continued in further 
packet(s). Unused bytes at the end of the last packet should be set to 
zero. The format of the separate Data Sets (one byte each) is described 
below.<BR>
The length of each line reaches from one end of the screen to the other 
end. In case that some lines overlap each other, then lines from 
lastmost data sets will overwrite lines from previous data sets.<BR>
<BR>
<B>SGB Command 06h - ATTR_DIV<BR>
</B>Used to split the screen into two halfes, and to assign separate color 
attributes to each half, and to the division line between them.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length   (fixed length=1)
  1     Color Palette Numbers and H/V Mode Bit
          Bit 0-1  Palette Number below/right of division line
          Bit 2-3  Palette Number above/left of division line
          Bit 4-5  Palette Number for division line
          Bit 6    H/V Mode Bit  (0=split left/right, 1=split above/below)
  2     X- or Y-Coordinate (depending on H/V bit)
  3-F   Not used (zero)
</TD></TR></TABLE><BR>
<B>SGB Command 07h - ATTR_CHR<BR>
</B>Used to specify color attributes for separate characters.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (length=1..6)
  1     Beginning X-Coordinate
  2     Beginning Y-Coordinate
  3-4   Number of Data Sets (1-360)
  5     Writing Style   (0=Left to Right, 1=Top to Bottom)
  6     Data Sets 1-4   (Set 1 in MSBs, Set 4 in LSBs)
  7     Data Sets 5-8   (if any)
  8     Data Sets 9-12  (if any)
  etc.
</TD></TR></TABLE>When sending 41 or more data sets, data is continued in further 
packet(s). Unused bytes at the end of the last packet should be set to 
zero. Each data set consists of two bits, indicating the palette number 
for one character.<BR>
Depending on the writing style, data sets are written from left to 
right, or from top to bottom. In either case the function wraps to the 
next row/column when reaching the end of the screen.<BR>
<BR>
<B>SGB Command 15h - ATTR_TRN<BR>
</B>Used to initialize Attribute Files (ATFs) in SNES RAM. Each ATF consists 
of 20x18 color attributes for the gameboy screen. This function does not 
directly affect display attributes. Instead, one of the defined ATFs may 
be copied to actual display memory at a later time by using ATTR_SET or 
PAL_SET functions.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)
</TD></TR></TABLE>The ATF data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000-FD1  Data for ATF0 through ATF44 (4050 bytes)
  FD2-FFF  Not used
</TD></TR></TABLE>Each ATF consists of 90 bytes, that are 5 bytes (20x2bits) for each of 
the 18 character lines of the gameboy window. The two most significant 
bits of the first byte define the color attribute (0-3) for the first 
character of the first line, the next two bits the next character, and 
so on.<BR>
<BR>
<B>SGB Command 16h - ATTR_SET<BR>
</B>Used to transfer attributes from Attribute File (ATF) to gameboy window.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Attribute File Number (00-2Ch), Bit 6=Cancel Mask
  2-F   Not used (zero)
</TD></TR></TABLE>When above Bit 6 is set, the gameboy screen becomes re-enabled after the 
transfer (in case it has been disabled/frozen by MASK_EN command).<BR>
Note: The same functions may be (optionally) also included in PAL_SET 
commands, as described in the chapter about Color Palette Commands.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbsoundfunctions"></A><FONT SIZE=+2>&nbsp;SGB Sound Functions</FONT></TD></TR></TABLE><BR>
<B>SGB Command 08h - SOUND<BR>
</B>Used to start/stop internal sound effect, start/stop sound using 
internal tone data.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Sound Effect A (Port 1) Decrescendo 8bit Sound Code
  2     Sound Effect B (Port 2) Sustain     8bit Sound Code
  3     Sound Effect Attributes
          Bit 0-1 - Sound Effect A Pitch  (0..3=Low..High)
          Bit 2-3 - Sound Effect A Volume (0..2=High..Low, 3=Mute on)
          Bit 4-5 - Sound Effect B Pitch  (0..3=Low..High)
          Bit 6-7 - Sound Effect B Volume (0..2=High..Low, 3=Not used)
  4     Music Score Code (must be zero if not used)
  5-F   Not used (zero)
</TD></TR></TABLE>See Sound Effect Tables below for a list of available pre-defined effects.<BR>
"Notes"<BR>
1) Mute is only active when both bits D2 and D3 are 1.<BR>
2) When the volume is set for either Sound Effect A or Sound Effect B, 
mute is turned off.<BR>
3) When Mute on/off has been executed, the sound fades out/fades in.<BR>
4) Mute on/off operates on the (BGM) which is reproduced by Sound Effect 
A, Sound Effect B, and the Super NES APU. A "mute off" flag does not 
exist by itself. When mute flag is set, volume and pitch of Sound Effect 
A (port 1) and Sound Effect B (port 2) must be set.<BR>
<BR>
<B>SGB Command 09h - SOU_TRN<BR>
</B>Used to transfer sound code or data to SNES Audio Processing Unit memory 
(APU-RAM).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1-F   Not used (zero)
</TD></TR></TABLE>The sound code/data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000      One (or two ???) 16bit expression(s ???) indicating the
           transfer destination address and transfer length.
  ...-...  Transfer Data
  ...-FFF  Remaining bytes not used
</TD></TR></TABLE>Possible destinations in APU-RAM are:<BR>
<TABLE><TR><TD><PRE>  0400h-2AFFh  APU-RAM Program Area (9.75KBytes)
  2B00h-4AFFh  APU-RAM Sound Score Area (8Kbytes)
  4DB0h-EEFFh  APU-RAM Sampling Data Area (40.25 Kbytes)
</TD></TR></TABLE>This function may be used to take control of the SNES sound chip, and/or 
to access the SNES MIDI engine. In either case it requires deeper 
knowledge of SNES sound programming.<BR>
<BR>
<B>SGB Sound Effect A/B Tables<BR>
</B>Below lists the digital sound effects that are pre-defined in the 
SGB/SNES BIOS, and which can be used with the SGB "SOUND" Command.<BR>
Effect A and B may be simultaneously reproduced.<BR>
The P-column indicates the recommended Pitch value, the V-column 
indicates the numbers of Voices used. Sound Effect A uses voices 6,7. 
Sound Effect B uses voices 0,1,4,5. Effects that use less voices will 
use only the upper voices (eg. 4,5 for Effect B with only two voices).<BR>
<BR>
<B>Sound Effect A Flag Table<BR>
</B><TABLE><TR><TD><PRE>  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 2     18  Fast Jump                3 1
  80  Effect A, stop/silent    - 2     19  Jet (rocket) takeoff     0 1
  01  Nintendo                 3 1     1A  Jet (rocket) landing     0 1
  02  Game Over                3 2     1B  Cup breaking             2 2
  03  Drop                     3 1     1C  Glass breaking           1 2
  04  OK ... A                 3 2     1D  Level UP                 2 2
  05  OK ... B                 3 2     1E  Insert air               1 1
  06  Select...A               3 2     1F  Sword swing              1 1
  07  Select...B               3 1     20  Water falling            2 1
  08  Select...C               2 2     21  Fire                     1 1
  09  Mistake...Buzzer         2 1     22  Wall collapsing          1 2
  0A  Catch Item               2 2     23  Cancel                   1 2
  0B  Gate squeaks 1 time      2 2     24  Walking                  1 2
  0C  Explosion...small        1 2     25  Blocking strike          1 2
  0D  Explosion...medium       1 2     26  Picture floats on & off  3 2
  0E  Explosion...large        1 2     27  Fade in                  0 2
  0F  Attacked...A             3 1     28  Fade out                 0 2
  10  Attacked...B             3 2     29  Window being opened      1 2
  11  Hit (punch)...A          0 2     2A  Window being closed      0 2
  12  Hit (punch)...B          0 2     2B  Big Laser                3 2
  13  Breath in air            3 2     2C  Stone gate closes/opens  0 2
  14  Rocket Projectile...A    3 2     2D  Teleportation            3 1
  15  Rocket Projectile...B    3 2     2E  Lightning                0 2
  16  Escaping Bubble          2 1     2F  Earthquake               0 2
  17  Jump                     3 1     30  Small Laser              2 2
</TD></TR></TABLE>Sound effect A is used for formanto sounds (percussion sounds).<BR>
<BR>
<B>Sound Effect B Flag Table<BR>
</B><TABLE><TR><TD><PRE>  Code Description             P V     Code Description             P V
  00  Dummy flag, re-trigger   - 4     0D  Waterfall                2 2
  80  Effect B, stop/silent    - 4     0E  Small character running  3 1
  01  Applause...small group   2 1     0F  Horse running            3 1
  02  Applause...medium group  2 2     10  Warning sound            1 1
  03  Applause...large group   2 4     11  Approaching car          0 1
  04  Wind                     1 2     12  Jet flying               1 1
  05  Rain                     1 1     13  UFO flying               2 1
  06  Storm                    1 3     14  Electromagnetic waves    0 1
  07  Storm with wind/thunder  2 4     15  Score UP                 3 1
  08  Lightning                0 2     16  Fire                     2 1
  09  Earthquake               0 2     17  Camera shutter, formanto 3 4
  0A  Avalanche                0 2     18  Write, formanto          0 1
  0B  Wave                     0 1     19  Show up title, formanto  0 1
  0C  River                    3 2
</TD></TR></TABLE>Sound effect B is mainly used for looping sounds (sustained sounds).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbsystemcontrolcommands"></A><FONT SIZE=+2>&nbsp;SGB System Control Commands</FONT></TD></TR></TABLE><BR>
<B>SGB Command 17h - MASK_EN<BR>
</B>Used to mask the gameboy window, among others this can be used to freeze 
the gameboy screen before transferring data through VRAM (the SNES then 
keeps displaying the gameboy screen, even though VRAM doesn't contain 
meaningful display information during the transfer).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Gameboy Screen Mask (0-3)
          0  Cancel Mask   (Display activated)
          1  Freeze Screen (Keep displaying current picture)
          2  Blank Screen  (Black)
          3  Blank Screen  (Color 0)
  2-F   Not used (zero)
</TD></TR></TABLE>Freezing works only if the SNES has stored a picture, ie. if necessary 
wait one or two frames before freezing (rather than freezing directly 
after having displayed the picture).<BR>
The Cancel Mask function may be also invoked (optionally) by completion 
of PAL_SET and ATTR_SET commands.<BR>
<BR>
<B>SGB Command 0Ch - ATRC_EN<BR>
</B>Used to enable/disable Attraction mode. It is totally unclear what an 
attraction mode is ???, but it is enabled by default.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Attraction Disable  (0=Enable, 1=Disable)
  2-F   Not used (zero)
</TD></TR></TABLE><BR>
<B>SGB Command 0Dh - TEST_EN<BR>
</B>Used to enable/disable test mode for "SGB-CPU variable clock speed 
function". This function is disabled by default.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Test Mode Enable    (0=Disable, 1=Enable)
  2-F   Not used (zero)
</TD></TR></TABLE>Maybe intended to determine whether SNES operates at 50Hz or 60Hz 
display refresh rate ??? Possibly result can be read-out from joypad 
register ???<BR>
<BR>
<B>SGB Command 0Eh - ICON_EN<BR>
</B>Used to enable/disable ICON function. Possibly meant to enable/disable 
SGB/SNES popup menues which might otherwise activated during gameboy 
game play. By default all functions are enabled (0).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Disable Bits
          Bit 0 - Use of SGB-Built-in Color Palettes    (1=Disable)
          Bit 1 - Controller Set-up Screen    (0=Enable, 1=Disable)
          Bit 2 - SGB Register File Transfer (0=Receive, 1=Disable)
          Bit 3-6 - Not used (zero)
  2-F   Not used (zero)
</TD></TR></TABLE>Above Bit 2 will suppress all further packets/commands when set, this 
might be useful when starting a monochrome game from inside of the 
SGB-menu of a multi-gamepak which contains a collection of different 
games.<BR>
<BR>
<B>SGB Command 0Fh - DATA_SND<BR>
</B>Used to write one or more bytes directly into SNES Work RAM.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4     Number of bytes to write (01h-0Bh)
  5     Data Byte #1
  6     Data Byte #2 (if any)
  7     Data Byte #3 (if any)
  etc.
</TD></TR></TABLE>Unused bytes at the end of the packet should be set to zero, this 
function is restricted to a single packet, so that not more than 11 
bytes can be defined at once.<BR>
Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 
0000h-FFFFh.<BR>
<BR>
<B>SGB Command 10h - DATA_TRN<BR>
</B>Used to transfer binary code or data directly into SNES RAM.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Destination Address, low
  2     SNES Destination Address, high
  3     SNES Destination Address, bank number
  4-F   Not used (zero)
</TD></TR></TABLE>The data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000-FFF  Data
</TD></TR></TABLE>Free Addresses in SNES memory are Bank 0 1800h-1FFFh, Bank 7Fh 
0000h-FFFFh. The transfer length is fixed at 4KBytes ???, so that directly 
writing to the free 2KBytes at 0:1800h would be a not so good idea ???<BR>
<BR>
<B>SGB Command 12h - JUMP<BR>
</B>Used to set the SNES program counter to a specified address. Optionally, 
it may be used to set a new address for the SNES NMI handler, the NMI 
handler remains unchanged if all bytes 4-6 are zero.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     SNES Program Counter, low
  2     SNES Program Counter, high
  3     SNES Program Counter, bank number
  4     SNES NMI Handler, low
  5     SNES NMI Handler, high
  6     SNES NMI Handler, bank number
  7-F   Not used, zero
</TD></TR></TABLE>Note: The game "Space Invaders 94" uses this function when selecting 
"Arcade mode" to execute SNES program code which has been previously 
transferred from the SGB to the SNES. The type of the CPU which is used 
in the SNES is unknown ???<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbmultiplayercommand"></A><FONT SIZE=+2>&nbsp;SGB Multiplayer Command</FONT></TD></TR></TABLE><BR>
<B>SGB Command 11h - MLT_REQ<BR>
</B>Used to request multiplayer mode (ie. input from more than one joypad).<BR>
Because this function provides feedback from the SGB/SNES to the gameboy 
program, it is also used to detect SGB hardware.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Multiplayer Control (0-3) (Bit0=Enable, Bit1=Two/Four Players)
          0 = One player
          1 = Two players
          3 = Four players
  2-F   Not used (zero)
</TD></TR></TABLE>In one player mode, the second joypad (if any) is used for the SGB 
system program. In two player mode, both joypads are used for the game. 
Because SNES have only two joypad sockets, four player mode requires an 
external "Multiplayer 5" adapter.<BR>
<BR>
<B>Reading Multiple Controllers (Joypads)<BR>
</B>When having enabled multiple controllers by MLT_REQ, data for each 
joypad can be read out through JOYPAD register (FF00) as follows: First 
set P14 and P15 both HIGH (deselect both Buttons and Cursor keys), you 
can now read the lower 4bits of FF00 which indicate the joypad ID for 
the following joypad input:<BR>
<TABLE><TR><TD><PRE>  0Fh  Joypad 1
  0Eh  Joypad 2
  0Dh  Joypad 3
  0Ch  Joypad 4
</TD></TR></TABLE>Next, set P14 and P15 low (one after each other) to select Buttons and 
Cursor lines, and read-out joypad state as normally. When completed, set 
P14 and P15 back HIGH, this automatically increments the joypad number 
(or restarts counting once reached the lastmost joypad). Repeat the 
procedure until you have read-out states for all two (or four) joypads.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="sgbborderandobjcommands"></A><FONT SIZE=+2>&nbsp;SGB Border and OBJ Commands</FONT></TD></TR></TABLE><BR>
<B>SGB Command 13h - CHR_TRN<BR>
</B>Used to transfer tile data (characters) to SNES Tile memory in VRAM. This 
normally used to define BG tiles for the SGB Border (see PCT_TRN), but 
might be also used to define moveable SNES foreground sprites (see 
OBJ_TRN).<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1     Tile Transfer Destination
          Bit 0   - Tile Numbers   (0=Tiles 00h-7Fh, 1=Tiles 80h-FFh)
          Bit 1   - Tile Type      (0=BG Tiles, 1=OBJ Tiles)
          Bit 2-7 - Not used (zero)
  2-F   Not used (zero)
</TD></TR></TABLE>The tile data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000-FFF  Bitmap data for 128 Tiles
</TD></TR></TABLE>Each tile occupies 16bytes (8x8 pixels, 16 colors each).<BR>
When intending to transfer more than 128 tiles, call this function twice 
(once for tiles 00h-7Fh, and once for tiles 80h-FFh). Note: The BG/OBJ 
Bit seems to have no effect and writes to the same VRAM addresses for 
both BG and OBJ ???<BR>
<BR>
<B>SGB Command 14h - PCT_TRN<BR>
</B>Used to transfer tile map data and palette data to SNES BG Map memory in 
VRAM to be used for the SGB border. The actual tiles must be separately 
transferred by using the CHR_TRN function.<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length    (fixed length=1)
  1-F   Not used (zero)
</TD></TR></TABLE>The map data is sent by VRAM-Transfer (4 KBytes).<BR>
<TABLE><TR><TD><PRE>  000-7FF  BG Map 32x32 Entries of 16bit each (2048 bytes)
  800-87F  BG Palette Data (Palettes 4-7, each 16 colors of 16bits each)
  880-FFF  Not used, don't care
</TD></TR></TABLE>Each BG Map Entry consists of a 16bit value as such:<BR>
<TABLE><TR><TD><PRE>  Bit 0-9   - Character Number (use only 00h-FFh, upper 2 bits zero)
  Bit 10-12 - Palette Number   (use only 4-7, officially use only 4-6)
  Bit 13    - BG Priority      (use only 0)
  Bit 14    - X-Flip           (0=Normal, 1=Mirror horizontally)
  Bit 15    - Y-Flip           (0=Normal, 1=Mirror vertically)
</TD></TR></TABLE>Even though 32x32 map entries are transferred, only upper 32x28 are 
actually used (256x224 pixels, SNES screen size). The 20x18 entries in 
the center of the 32x28 area should be set to 0000h as transparent space 
for the gameboy window to be displayed inside. Reportedly, 
non-transparent border data will cover the gameboy window.<BR>
<BR>
<B>SGB Command 18h - OBJ_TRN<BR>
</B>Used to transfer OBJ attributes to SNES OAM memory. Unlike all other 
functions with the ending _TRN, this function does not use the usual 
one-shot 4KBytes VRAM transfer method.<BR>
Instead, when enabled (below execute bit set), data is permanently (each 
frame) read out from the lower character line of the gameboy screen. To 
suppress garbage on the display, the lower line is masked, and only the 
upper 20x17 characters of the gameboy window are used - the masking 
method is unknwon - frozen, black, or recommended to be covered by the 
SGB border, or else ??? Also, when the function is enabled, "system 
attract mode is not performed" - whatever that means ???<BR>
<TABLE><TR><TD><PRE>  Byte  Content
  0     Command*8+Length (fixed length=1)
  1     Control Bits
          Bit 0   - SNES OBJ Mode enable (0=Cancel, 1=Enable)
          Bit 1   - Change OBJ Color     (0=No, 1=Use definitions below)
          Bit 2-7 - Not used (zero)
  2-3   System Color Palette Number for OBJ Palette 4 (0-511)
  4-5   System Color Palette Number for OBJ Palette 5 (0-511)
  6-7   System Color Palette Number for OBJ Palette 6 (0-511)
  8-9   System Color Palette Number for OBJ Palette 7 (0-511)
          These color entries are ignored if above Control Bit 1 is zero.
          Because each OBJ palette consists of 16 colors, four system
          palette entries (of 4 colors each) are transferred into each
          OBJ palette. The system palette numbers are not required to be
          aligned to a multiple of four, and will wrap to palette number
          0 when exceeding 511. For example, a value of 511 would copy
          system palettes 511, 0, 1, 2 to the SNES OBJ palette.
  A-F   Not used (zero)
</TD></TR></TABLE>The recommended method is to "display" gameboy BG tiles F9h..FFh from 
left to right as first 7 characters of the bottom-most character line of 
the gameboy screen. As for normal 4KByte VRAM transfers, this area 
should not be scrolled, should not be overlapped by gameboy OBJs, and 
the gameboy BGP palette register should be set up properly. By following 
that method, SNES OAM data can be defined in the 70h bytes of the 
gameboy BG tile memory at following addresses:<BR>
<TABLE><TR><TD><PRE>  8F90-8FEF  SNES OAM, 24 Entries of 4 bytes each (96 bytes)
  8FF0-8FF5  SNES OAM MSBs, 24 Entries of 2 bits each (6 bytes)
  8FF6-8FFF  Not used, don't care (10 bytes)
</TD></TR></TABLE>The format of SNES OAM Entries is:<BR>
<TABLE><TR><TD><PRE>  Byte 0  OBJ X-Position (0-511, MSB is separately stored, see below)
  Byte 1  OBJ Y-Position (0-255)
  Byte 2-3  Attributes (16bit)
    Bit 0-8    Tile Number     (use only 00h-FFh, upper bit zero)
    Bit 9-11   Palette Number  (use only 4-7)
    Bit 12-13  OBJ Priority    (use only 3)
    Bit 14     X-Flip          (0=Normal, 1=Mirror horizontally)
    Bit 15     Y-Flip          (0=Normal, 1=Mirror vertically)
</TD></TR></TABLE>The format of SNES OAM MSB Entries is:<BR>
<TABLE><TR><TD><PRE>  Actually, the format is unknown ??? However, 2 bits are used per entry:
  One bit is the most significant bit of the OBJ X-Position.
  The other bit specifies the OBJ size (8x8 or 16x16 pixels).
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="cpuregistersandflags"></A><FONT SIZE=+2>&nbsp;CPU 寄存器与标志位</FONT></TD></TR></TABLE><BR>
<B>寄存器<BR>
</B><TABLE><TR><TD><PRE>  16位  高   低   名字/功能
  AF    A    -    累加器 & 标志位
  BC    B    C    BC
  DE    D    E    DE
  HL    H    L    HL
  SP    -    -    堆栈指针
  PC    -    -    程序计数器/指针
</TD></TR></TABLE>如上所示, 大部分寄存器能以1个16位寄存器, 或者2个独立的8位寄存器来访问.<BR>
<BR>
<B>标志位寄存器 (AF 寄存器的低8位)<BR>
</B><TABLE><TR><TD><PRE>  位   名字  设置 清除 说明
  7    zf    Z    NZ   零标志位
  6    n     -    -    加减标志位 (BCD)
  5    h     -    -    半溢出标志位 (BCD)
  4    cy    C    NC   溢出标志位
  3-0  -     -    -    不使用 (总是为0)
</TD></TR></TABLE>装有近期影响标志位的指令的结果.<BR>
<BR>
<B>零标志位 (Z)<BR>
</B>这个标志位将在一个操作的结果为零 (0) 时被设置 (1). 用于条件跳转.<BR>
<BR>
<B>溢出标志位 (C 或者叫 Cy)<BR>
</B>当一个加法结果大于 FFh (8位) 或者 FFFFh (16位) 时, 或者当减法/比较的结果小于零时, 这个标志位被设置 (减法的溢出设置方式与 Z80 与 80x86 的 CPU 相同, 但和 65XX 与 ARM 的 CPU 不同). 另外, 当移位/循环移位移出的位是 "1" 时, 这个标志位也被设置. 用于条件跳转, 以及如 ADC, SBC, RL, RLA 等指令.<BR>
<BR>
<B>BCD 标志位 (N, H)<BR>
</B>These flags are (rarely) used for the DAA instruction only, N Indicates 
whether the previous instruction has been an addition or subtraction, 
and H indicates carry for lower 4bits of the result, also for DAA, the C 
flag must indicate carry for upper 8bits.<BR>
After adding/subtracting two BCD numbers, DAA is intended to convert the 
result into BCD format; BCD numbers are ranged from 00h to 99h rather 
than 00h to FFh.<BR>
Because C and H flags must contain carry-outs for each digit, DAA cannot 
be used for 16bit operations (which have 4 digits), or for INC/DEC 
operations (which do not affect C-flag).<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="cpuinstructionset"></A><FONT SIZE=+2>&nbsp;CPU 指令集</FONT></TD></TR></TABLE><BR>
下面的表格依次列出了助记符, 操作码, 时钟周期, 影响的标志位 (顺序是 znhc), 指令说明.<BR>
周期数使得 CPU 的时钟频率设定在 4.194304 MHz (在 CGB 倍速模式下为 8.4 MHz), <BR>
因为 Gameboy 所有的周期数都可以被 4 整除, 许多人将周期数和时钟频率也除以 4. <BR>
<BR>
<B>GMB 8位装载指令<BR>
</B><TABLE><TR><TD><PRE>  ld   r,r         xx         4 ---- r=r
  ld   r,n         xx nn      8 ---- r=n
  ld   r,(HL)      xx         8 ---- r=(HL)
  ld   (HL),r      7x         8 ---- (HL)=r
  ld   (HL),n      36 nn     12 ---- (HL)=n
  ld   A,(BC)      0A         8 ---- A=(BC)
  ld   A,(DE)      1A         8 ---- A=(DE)
  ld   A,(nn)      FA        16 ---- A=(nn)
  ld   (BC),A      02         8 ---- (BC)=A
  ld   (DE),A      12         8 ---- (DE)=A
  ld   (nn),A      EA        16 ---- (nn)=A
  ld   A,(FF00+n)  F0 nn     12 ---- 从 I/O 端口 n 读取 (内存 FF00+n)
  ld   (FF00+n),A  E0 nn     12 ---- 向 I/O 端口 n 写入 (内存 FF00+n)
  ld   A,(FF00+C)  F2         8 ---- 从 I/O 端口 C 读取 (内存 FF00+C)
  ld   (FF00+C),A  E2         8 ---- 向 I/O 端口 C 写入 (内存 FF00+C)
  ldi  (HL),A      22         8 ---- (HL)=A, HL=HL+1
  ldi  A,(HL)      2A         8 ---- A=(HL), HL=HL+1
  ldd  (HL),A      32         8 ---- (HL)=A, HL=HL-1
  ldd  A,(HL)      3A         8 ---- A=(HL), HL=HL-1
</TD></TR></TABLE><BR>
<B>GMB 16位装载指令<BR>
</B><TABLE><TR><TD><PRE>  ld   rr,nn       x1 nn nn  12 ---- rr=nn            ;rr 可以是 BC,DE,HL,SP
  ld   SP,HL       F9         8 ---- SP=HL
  ld   (nn),SP     08 nn nn  20 ---- (nn)=SP
  push rr          x5        16 ---- SP=SP-2  (SP)=rr ;rr 可以是 BC,DE,HL,AF
  pop  rr          x1        12 (AF) rr=(SP)  SP=SP+2 ;rr 可以是 BC,DE,HL,AF
</TD></TR></TABLE><BR>
<B>GMB 8位算术运算/逻辑运算指令<BR>
</B><TABLE><TR><TD><PRE>  add  A,r         8x         4 z0hc A=A+r
  add  A,n         C6 nn      8 z0hc A=A+n
  add  A,(HL)      86         8 z0hc A=A+(HL)
  adc  A,r         8x         4 z0hc A=A+r+cy
  adc  A,n         CE nn      8 z0hc A=A+n+cy
  adc  A,(HL)      8E         8 z0hc A=A+(HL)+cy
  sub  r           9x         4 z1hc A=A-r
  sub  n           D6 nn      8 z1hc A=A-n
  sub  (HL)        96         8 z1hc A=A-(HL)
  sbc  A,r         9x         4 z1hc A=A-r-cy
  sbc  A,n         DE nn      8 z1hc A=A-n-cy
  sbc  A,(HL)      9E         8 z1hc A=A-(HL)-cy
  and  r           Ax         4 z010 A=A & r
  and  n           E6 nn      8 z010 A=A & n
  and  (HL)        A6         8 z010 A=A & (HL)
  xor  r           Ax         4 z000 A=A xor r
  xor  n           EE nn      8 z000 A=A xor n
  xor  (HL)        AE         8 z000 A=A xor (HL)
  or   r           Bx         4 z000 A=A | r
  or   n           F6 nn      8 z000 A=A | n
  or   (HL)        B6         8 z000 A=A | (HL)
  cp   r           Bx         4 z1hc 比较 A-r
  cp   n           FE nn      8 z1hc 比较 A-n
  cp   (HL)        BE         8 z1hc 比较 A-(HL)
  inc  r           xx         4 z0h- r=r+1
  inc  (HL)        34        12 z0h- (HL)=(HL)+1
  dec  r           xx         4 z1h- r=r-1
  dec  (HL)        35        12 z1h- (HL)=(HL)-1
  daa              27         4 z-0x 十进制调整 A
  cpl              2F         4 -11- A = A xor FF     ;A取反
</TD></TR></TABLE><BR>
<B>GMB 16位算术运算/逻辑运算指令<BR>
</B><TABLE><TR><TD><PRE>  add  HL,rr     x9           8 -0hc HL=HL+rr         ;rr 可以是 BC,DE,HL,SP
  inc  rr        x3           8 ---- rr=rr+1          ;rr 可以是 BC,DE,HL,SP
  dec  rr        xB           8 ---- rr=rr-1          ;rr 可以是 BC,DE,HL,SP
  add  SP,dd     E8          16 00hc SP=SP +/- dd     ;dd 是8位符号数
  ld   HL,SP+dd  F8          12 00hc HL=SP +/- dd     ;dd 是8位符号数
</TD></TR></TABLE><BR>
<B>GMB 位移/循环位移指令<BR>
</B><TABLE><TR><TD><PRE>  rlca           07           4 000c 循环左移 A
  rla            17           4 000c 带进位循环左移 A
  rrca           0F           4 000c 循环右移 A
  rra            1F           4 000c 带进位循环右移 A
  rlc  r         CB 0x        8 z00c 循环左移 r
  rlc  (HL)      CB 06       16 z00c 循环左移 (HL)
  rl   r         CB 1x        8 z00c 带进位循环左移 r
  rl   (HL)      CB 16       16 z00c 带进位循环左移 (HL)
  rrc  r         CB 0x        8 z00c 循环右移 r
  rrc  (HL)      CB 0E       16 z00c 循环右移 (HL)
  rr   r         CB 1x        8 z00c 带进位循环右移 r
  rr   (HL)      CB 1E       16 z00c 带进位循环右移 (HL)
  sla  r         CB 2x        8 z00c 算术左移 r        ;Bit 0=0
  sla  (HL)      CB 26       16 z00c 算术左移 (HL)     ;Bit 0=0
  swap r         CB 3x        8 z000 交换 r 高低半字节
  swap (HL)      CB 36       16 z000 交换 (HL) 高低半字节
  sra  r         CB 2x        8 z00c 算术右移 r        ;Bit 7=Bit 7
  sra  (HL)      CB 2E       16 z00c 算术右移 (HL)     ;Bit 7=Bit 7
  srl  r         CB 3x        8 z00c 逻辑右移 r        ;Bit 7=0
  srl  (HL)      CB 3E       16 z00c 逻辑右移 (HL)     ;Bit 7=0
</TD></TR></TABLE><BR>
<B>GMB 位操作指令<BR>
</B><TABLE><TR><TD><PRE>  bit  n,r       CB xx        8 z01- 测试 Bit n
  bit  n,(HL)    CB xx       12 z01- 测试 Bit n
  set  n,r       CB xx        8 ---- 设置 Bit n
  set  n,(HL)    CB xx       16 ---- 设置 Bit n
  res  n,r       CB xx        8 ---- 清除 Bit n
  res  n,(HL)    CB xx       16 ---- 清除 Bit n
</TD></TR></TABLE><BR>
<B>GMB CPU 控制指令<BR>
</B><TABLE><TR><TD><PRE>  ccf            3F           4 -00c cy=cy xor 1      ;cy取反
  scf            37           4 -001 cy=1
  nop            00           4 ---- 无操作
  halt           76         N*4 ---- 停机直到产生中断 (低功耗)
  stop           10 00        ? ---- 低功耗待机模式 (极低功耗)
  di             F3           4 ---- 关闭中断, IME=0
  ei             FB           4 ---- 开启中断, IME=1
</TD></TR></TABLE><BR>
<B>GMB 跳转指令<BR>
</B><TABLE><TR><TD><PRE>  jp   nn        C3 nn nn    16 ---- 跳转到 nn, PC=nn
  jp   HL        E9           4 ---- 跳转到 HL, PC=HL
  jp   f,nn      xx nn nn 16;12 ---- 条件跳转, 如果 nz,z,nc,c
  jr   PC+dd     18 dd       12 ---- 相对跳转到 nn (PC=PC+/-7 位)
  jr   f,PC+dd   xx dd     12;8 ---- 相对条件跳转, 如果 nz,z,nc,c
  call nn        CD nn nn    24 ---- 调用 nn, SP=SP-2, (SP)=PC, PC=nn
  call f,nn      xx nn nn 24;12 ---- 条件调用, 如果 nz,z,nc,c
  ret            C9          16 ---- 返回, PC=(SP), SP=SP+2
  ret  f         xx        20;8 ---- 条件返回, 如果 nz,z,nc,c
  reti           D9          16 ---- 返回并开启中断 (IME=1)
  rst  n         xx          16 ---- 调用 00,08,10,18,20,28,30,38
</TD></TR></TABLE><BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="cpucomparisionwithz80"></A><FONT SIZE=+2>&nbsp;CPU Comparision with Z80</FONT></TD></TR></TABLE><BR>
<B>Comparision with 8080<BR>
</B>Basically, the gameboy CPU works more like an older 8080 CPU rather than 
like a more powerful Z80 CPU. It is, however, supporting CB-prefixed 
instructions. Also, all known gameboy assemblers using the more obvious 
Z80-style syntax, rather than the chaotic 8080-style syntax.<BR>
<BR>
<B>Comparision with Z80<BR>
</B>Any DD-, ED-, and FD-prefixed instructions are missing, that means no 
IX-, IY-registers, no block commands, and some other missing commands.<BR>
All exchange instructions have been removed (including total absence of 
second register set), 16bit memory accesses are mostly missing, and 
16bit arithmetic functions are heavily cut-down.<BR>
The gameboy has no IN/OUT instructions, instead I/O ports are accessed 
directly by normal LD instructions, or by special LD (FF00+n) opcodes.<BR>
The sign and parity/overflow flags have been removed.<BR>
The gameboy operates approximately as fast as a 4MHz Z80 (8MHz in CGB 
double speed mode), execution time of all instructions has been rounded 
up to a multiple of 4 cycles though.<BR>
<BR>
<B>Moved, Removed, and Added Opcodes<BR>
</B><TABLE><TR><TD><PRE>  Opcode  Z80             GMB
  ---------------------------------------
  08      EX   AF,AF      LD   (nn),SP
  10      DJNZ PC+dd      STOP
  22      LD   (nn),HL    LDI  (HL),A
  2A      LD   HL,(nn)    LDI  A,(HL)
  32      LD   (nn),A     LDD  (HL),A
  3A      LD   A,(nn)     LDD  A,(HL)
  D3      OUT  (n),A      -
  D9      EXX             RETI
  DB      IN   A,(n)      -
  DD      &lt;IX&gt;            -
  E0      RET  PO         LD   (FF00+n),A
  E2      JP   PO,nn      LD   (FF00+C),A
  E3      EX   (SP),HL    -
  E4      CALL P0,nn      -
  E8      RET  PE         ADD  SP,dd
  EA      JP   PE,nn      LD   (nn),A
  EB      EX   DE,HL      -
  EC      CALL PE,nn      -
  ED      &lt;pref&gt;          -
  F0      RET  P          LD   A,(FF00+n)
  F2      JP   P,nn       LD   A,(FF00+C)
  F4      CALL P,nn       -
  F8      RET  M          LD   HL,SP+dd
  FA      JP   M,nn       LD   A,(nn)
  FC      CALL M,nn       -
  FD      &lt;IY&gt;            -
  CB3X    SLL  r/(HL)     SWAP r/(HL)
</TD></TR></TABLE>Note: The unused (-) opcodes will lock-up the gameboy CPU when used.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="thecartridgeheader"></A><FONT SIZE=+2>&nbsp;卡带头部</FONT></TD></TR></TABLE><BR>
一个内置的信息区位于每个卡带的 0100-014F.<BR>
它含有以下内容:<BR>
<BR>
<B>0100-0103 - 入口<BR>
</B>在显示完任天堂标志后, 内建的启动程序跳转到这个地址 (100h), 这里应跳转到卡带实际的主程序. 一般这个 4 字节的区域含有一个 NOP 指令, 然后跟着一个 JP 0150h 指令. 但这不是绝对的.<BR>
<BR>
<B>0104-0133 - 任天堂标志<BR>
</B>这些字节定义了 Gameboy 开机时显示的任天堂标志的位图. 这个位图的十六位数据是:<BR>
<TABLE><TR><TD><PRE>  CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D
  00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99
  BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E
</TD></TR></TABLE>Gameboy 启动程序在显示这张位图后将验证其中的内容, 如果这些字节不匹配, Gameboy 将自锁. CGB 只验证位图的前 18h 个字节, 但是其他设备 (比如 Pocket Gameboy) 验证全部 30h 字节.<BR>
<BR>
<B>0134-0143 - 标题<BR>
</B>大写 ASCII 的游戏标题. 如果标题少于 16 个字节, 剩余的字节填入 00. CGB 出现后, 任天堂减少了这个区域到 15 个字节. 再过了几个月后他们一个荒唐的主意让这个区域只剩 11 个字节. 这些原本是标题字节的新定义见下述.<BR>
<BR>
<B>013F-0142 - 生产商代码<BR>
</B>早期卡带这个区域是标题的一部分 (见上), 在较新的卡带中这个区域包含以 4 个大写字母组成的生产商代码. 缘由未知.<BR>
<BR>
<B>0143 - CGB 标志<BR>
</B>早期卡带这个字节是标题的一部分 (见上). 在 CGB 卡带中最高位被用于启用 CGB 功能. 这个位为 CGB 所需, 否则 CGB 将切换自己为非 CGB 模式. 典型值为:<BR>
<TABLE><TR><TD><PRE>  80h - 游戏支持 CGB 功能, 但是也能在旧 Gameboy 上运行.
  C0h - 游戏只在 CGB 上运行. (硬件上与 80h 相同).
</TD></TR></TABLE>设置值的 Bit 7, 以及 Bit 2 或者 3 被设置, 将切换 Gameboy 到一个有着未初始化调色板的特殊非 CGB 模式. 原因未知, 大概是用于彩色化在 ROM 的特殊位置带有固定调色板数据的单色游戏.<BR>
<BR>
<B>0144-0145 - 新授权代码<BR>
</B>指定以两个 ASCII 字符组成的授权代码, 包含公司或游戏的发行商. 这两个字节只用于较新的游戏 (在 SGB 出现后所发行的游戏). 较旧的游戏使用头部项 014B.<BR>
<BR>
<B>0146 - SGB 标志<BR>
</B>指定游戏是否支持 SGB 功能, 常见的值为:<BR>
<TABLE><TR><TD><PRE>  00h = 无 SGB 功能 (普通 Gameboy 或者 CGB 专用游戏)
  03h = 游戏支持 SGB 功能
</TD></TR></TABLE>如果这个字节不是 03h, SGB 将关闭 SGB 功能.<BR>
<BR>
<B>0147 - 卡带类型<BR>
</B>指定卡带使用哪种 MBC (内存页面控制器) (如果有的话), 以及是否有外部硬件存在于卡带之内.<BR>
<TABLE><TR><TD><PRE>  00h  只有 ROM                 19h  MBC5
  01h  MBC1                     1Ah  MBC5+RAM
  02h  MBC1+RAM                 1Bh  MBC5+RAM+电池
  03h  MBC1+RAM+电池            1Ch  MBC5+震动
                                1Dh  MBC5+震动+RAM
  05h  MBC2                     1Eh  MBC5+震动+RAM+电池
  06h  MBC2+电池
                                20h  MBC6+FLASH+RAM+电池
  08h  ROM+RAM
  09h  ROM+RAM+电池             22h  MBC7+加速度传感器+震动+RAM+电池
       
  0Bh  MMM01                    FCh  口袋照相机
  0Ch  MMM01+RAM                FDh  万代拓麻歌子5
  0Dh  MMM01+RAM+电池           FEh  HuC3
                                FFh  HuC1+RAM+电池
  0Fh  MBC3+实时时钟+电池
  10h  MBC3+实时时钟+RAM+电池   
  11h  MBC3
  12h  MBC3+RAM
  13h  MBC3+RAM+电池
</TD></TR></TABLE><BR>
<B>0148 - ROM 大小<BR>
</B>指定卡带上 ROM 的大小. 通常计算方法是 "32KB shl N (32KB 乘 2 的 N 次方)".<BR>
<TABLE><TR><TD><PRE>  00h -  32K 字节 (ROM 没有分 Bank)
  01h -  64K 字节 (  4 个 Bank)
  02h - 128K 字节 (  8 个 Bank)
  03h - 256K 字节 ( 16 个 Bank)
  04h - 512K 字节 ( 32 个 Bank)
  05h -   1M 字节 ( 64 个 Bank) - MBC1 仅使用其中  63 个 Bank
  06h -   2M 字节 (128 个 Bank) - MBC1 仅使用其中 125 个 Bank
  07h -   4M 字节 (256 个 Bank)
  52h - 1.1M 字节 ( 72 个 Bank)
  53h - 1.2M 字节 ( 80 个 Bank)
  54h - 1.5M 字节 ( 96 个 Bank)
</TD></TR></TABLE><BR>
<B>0149 - RAM 大小<BR>
</B>指定卡带上外部 RAM 的大小 (如果有的话).<BR>
<TABLE><TR><TD><PRE>  00h -   0K 无
  01h -   2K 字节
  02h -   8K 字节
  03h -  32K 字节 ( 4 个 Bank, 每个 Bank 8K 字节)
  04h - 128K 字节 (16 个 Bank, 每个 Bank 8K 字节)
  05h -  64K 字节 ( 8 个 Bank, 每个 Bank 8K 字节)
</TD></TR></TABLE>使用 MBC2 芯片时, 此项指定为 00h, 虽然 MBC2 含有内建的 512 x 4 位 RAM.<BR>
<BR>
<B>014A - 区域代码<BR>
</B>指定此版本游戏将要在日本或其他区域发售. 只有定义了两个值.<BR>
<TABLE><TR><TD><PRE>  00h - 日版
  01h - 非日版
</TD></TR></TABLE><BR>
<B>014B - 旧授权代码<BR>
</B>指定游戏公司/开发商代码, 范围 00-FFh. 值 33h 表示使用在头部字节 0144-0145 的新授权代码代替.<BR>
(Super GameBoy 功能在这个值不等于 $33 时不启用.)<BR>
<BR>
<B>014C - 掩模 ROM 版本号<BR>
</B>指定游戏的版本号. 一般是 00h.<BR>
<BR>
<B>014D - 头部校验和<BR>
</B>含有对卡带头部字节 0134-014C 的 8 位校验和.
校验和按如下方式计算:<BR>
<TABLE><TR><TD><PRE>  x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT
</TD></TR></TABLE>结果的低八位需要和这个值一样. 如果这个校验和不正确, 游戏将无法运行.<BR>
<BR>
<B>014E-014F - 全局校验和<BR>
</B>含有一个对整个卡带 ROM 的 16 位校验和 (高位字节在前, 即大端序). 通过计算卡带所有字节的和 (除了这两个校验字节) 得到. Gameboy 不会验证这个校验和.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="memorybankcontrollers"></A><FONT SIZE=+2>&nbsp;Memory Bank Controllers</FONT></TD></TR></TABLE><BR>
As the gameboys 16 bit address bus offers only limited space for ROM and 
RAM addressing, many games are using Memory Bank Controllers (MBCs) to 
expand the available address space by bank switching. These MBC chips 
are located in the game cartridge (ie. not in the gameboy itself), 
several different MBC types are available:<BR>
<BR>
<A HREF="#none32kbyteromonly">None (32KByte ROM only)</A><BR>
<A HREF="#mbc1max2mbyteromandor32kbyteram">MBC1 (max 2MByte ROM and/or 32KByte RAM)</A><BR>
<A HREF="#mbc2max256kbyteromand512x4bitsram">MBC2 (max 256KByte ROM and 512x4 bits RAM)</A><BR>
<A HREF="#mbc3max2mbyteromandor32kbyteramandtimer">MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer)</A><BR>
<A HREF="#huc1mbcwithinfraredcontroller">HuC1 (MBC with Infrared Controller)</A><BR>
<BR>
<A HREF="#mbctimingissues">MBC Timing Issues</A><BR>
<BR>
In each cartridge, the required (or preferred) MBC type should be 
specified in byte at 0147h of the ROM. (As described in the chapter 
about The Cartridge Header.)<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="none32kbyteromonly"></A><FONT SIZE=+2>&nbsp;None (32KByte ROM only)</FONT></TD></TR></TABLE><BR>
Small games of not more than 32KBytes ROM do not require a MBC chip for 
ROM banking. The ROM is directly mapped to memory at 0000-7FFFh. 
Optionally up to 8KByte of RAM could be connected at A000-BFFF, even 
though that could require a tiny MBC-like circuit, but no real MBC chip.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="mbc1max2mbyteromandor32kbyteram"></A><FONT SIZE=+2>&nbsp;MBC1 (max 2MByte ROM and/or 32KByte RAM)</FONT></TD></TR></TABLE><BR>
This is the first MBC chip for the gameboy. Any newer MBC chips are 
working similiar, so that is relative easy to upgrade a program from one 
MBC chip to another - or even to make it compatible to several different 
types of MBCs.<BR>
<BR>
Note that the memory in range 0000-7FFF is used for both reading from 
ROM, and for writing to the MBCs Control Registers.<BR>
<BR>
<B>0000-3FFF - ROM Bank 00 (Read Only)<BR>
</B>This area always contains the first 16KBytes of the cartridge ROM.<BR>
<BR>
<B>4000-7FFF - ROM Bank 01-7F (Read Only)<BR>
</B>This area may contain any of the further 16KByte banks of the ROM, 
allowing to address up to 125 ROM Banks (almost 2MByte). As described 
below, bank numbers 20h, 40h, and 60h cannot be used, resulting in the 
odd amount of 125 banks.<BR>
<BR>
<B>A000-BFFF - RAM Bank 00-03, if any (Read/Write)<BR>
</B>This area is used to address external RAM in the cartridge (if any). 
External RAM is often battery buffered, allowing to store game positions 
or high score tables, even if the gameboy is turned off, or if the 
cartridge is removed from the gameboy. Available RAM sizes are: 2KByte 
(at A000-A7FF), 8KByte (at A000-BFFF), and 32KByte (in form of four 8K 
banks at A000-BFFF).<BR>
<BR>
<B>0000-1FFF - RAM Enable (Write Only)<BR>
</B>Before external RAM can be read or written, it must be enabled by 
writing to this address space. It is recommended to disable external RAM 
after accessing it, in order to protect its contents from damage during 
power down of the gameboy. Usually the following values are used:<BR>
<TABLE><TR><TD><PRE>  00h  Disable RAM (default)
  0Ah  Enable RAM
</TD></TR></TABLE>Practically any value with 0Ah in the lower 4 bits enables RAM, and any 
other value disables RAM.<BR>
<BR>
<B>2000-3FFF - ROM Bank Number (Write Only)<BR>
</B>Writing to this address space selects the lower 5 bits of the ROM Bank 
Number (in range 01-1Fh). When 00h is written, the MBC translates that 
to bank 01h also. That doesn't harm so far, because ROM Bank 00h can be 
always directly accessed by reading from 0000-3FFF.<BR>
But (when using the register below to specify the upper ROM Bank bits), 
the same happens for Bank 20h, 40h, and 60h. Any attempt to address 
these ROM Banks will select Bank 21h, 41h, and 61h instead.<BR>
<BR>
<B>4000-5FFF - RAM Bank Number - or - Upper Bits of ROM Bank Number (Write Only)<BRBR>
</B>This 2bit register can be used to select a RAM Bank in range from 
00-03h, or to specify the upper two bits (Bit 5-6) of the ROM Bank 
number, depending on the current ROM/RAM Mode. (See below.)<BR>
<BR>
<B>6000-7FFF - ROM/RAM Mode Select (Write Only)<BR>
</B>This 1bit Register selects whether the two bits of the above register 
should be used as upper two bits of the ROM Bank, or as RAM Bank Number.<BR>
<TABLE><TR><TD><PRE>  00h = ROM Banking Mode (up to 8KByte RAM, 2MByte ROM) (default)
  01h = RAM Banking Mode (up to 32KByte RAM, 512KByte ROM)
</TD></TR></TABLE>The program may freely switch between both modes, the only limitiation 
is that only RAM Bank 00h can be used during Mode 0, and only ROM Banks 
00-1Fh can be used during Mode 1.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="mbc2max256kbyteromand512x4bitsram"></A><FONT SIZE=+2>&nbsp;MBC2 (max 256KByte ROM and 512x4 bits RAM)</FONT></TD></TR></TABLE><BR>
<B>0000-3FFF - ROM Bank 00 (Read Only)<BR>
</B>Same as for MBC1.<BR>
<BR>
<B>4000-7FFF - ROM Bank 01-0F (Read Only)<BR>
</B>Same as for MBC1, but only a total of 16 ROM banks is supported.<BR>
<BR>
<B>A000-A1FF - 512x4bits RAM, built-in into the MBC2 chip (Read/Write)<BR>
</B>The MBC2 doesn't support external RAM, instead it includes 512x4 bits of 
built-in RAM (in the MBC2 chip itself). It still requires an external 
battery to save data during power-off though.<BR>
As the data consists of 4bit values, only the lower 4 bits of the 
"bytes" in this memory area are used.<BR>
<BR>
<B>0000-1FFF - RAM Enable (Write Only)<BR>
</B>The least significant bit of the upper address byte must be zero to 
enable/disable cart RAM. For example the following addresses can be used 
to enable/disable cart RAM: 0000-00FF, 0200-02FF, 0400-04FF, ..., 
1E00-1EFF.<BR>
The suggested address range to use for MBC2 ram enable/disable is 
0000-00FF.<BR>
<BR>
<B>2000-3FFF - ROM Bank Number (Write Only)<BR>
</B>Writing a value (XXXXBBBB - X = Don't cares, B = bank select bits) into 
2000-3FFF area will select an appropriate ROM bank at 4000-7FFF.<BR>
<BR>
The least significant bit of the upper address byte must be one to 
select a ROM bank. For example the following addresses can be used to 
select a ROM bank: 2100-21FF, 2300-23FF, 2500-25FF, ..., 3F00-3FFF.<BR>
The suggested address range to use for MBC2 rom bank selection is 
2100-21FF.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="mbc3max2mbyteromandor32kbyteramandtimer"></A><FONT SIZE=+2>&nbsp;MBC3 (max 2MByte ROM and/or 32KByte RAM and Timer)</FONT></TD></TR></TABLE><BR>
Beside for the ability to access up to 2MB ROM (128 banks), and 32KB RAM 
(4 banks), the MBC3 also includes a built-in Real Time Clock (RTC). The 
RTC requires an external 32.768 kHz Quartz Oscillator, and an external 
battery (if it should continue to tick when the gameboy is turned off).<BR>
<BR>
<B>0000-3FFF - ROM Bank 00 (Read Only)<BR>
</B>Same as for MBC1.<BR>
<BR>
<B>4000-7FFF - ROM Bank 01-7F (Read Only)<BR>
</B>Same as for MBC1, except that accessing banks 20h, 40h, and 60h is 
supported now.<BR>
<BR>
<B>A000-BFFF - RAM Bank 00-03, if any (Read/Write)<BR>
A000-BFFF - RTC Register 08-0C (Read/Write)<BR>
</B>Depending on the current Bank Number/RTC Register selection (see below), 
this memory space is used to access an 8KByte external RAM Bank, or a 
single RTC Register.<BR>
<BR>
<B>0000-1FFF - RAM and Timer Enable (Write Only)<BR>
</B>Mostly the same as for MBC1, a value of 0Ah will enable reading and 
writing to external RAM - and to the RTC Registers! A value of 00h will 
disable either.<BR>
<BR>
<B>2000-3FFF - ROM Bank Number (Write Only)<BR>
</B>Same as for MBC1, except that the whole 7 bits of the RAM Bank Number 
are written directly to this address. As for the MBC1, writing a value 
of 00h, will select Bank 01h instead. All other values 01-7Fh select the 
corresponding ROM Banks.<BR>
<BR>
<B>4000-5FFF - RAM Bank Number - or - RTC Register Select (Write Only)<BR>
</B>As for the MBC1s RAM Banking Mode, writing a value in range for 00h-03h 
maps the corresponding external RAM Bank (if any) into memory at 
A000-BFFF.<BR>
When writing a value of 08h-0Ch, this will map the corresponding RTC 
register into memory at A000-BFFF. That register could then be 
read/written by accessing any address in that area, typically that is 
done by using address A000.<BR>
<BR>
<B>6000-7FFF - Latch Clock Data (Write Only)<BR>
</B>When writing 00h, and then 01h to this register, the current time 
becomes latched into the RTC registers. The latched data will not change 
until it becomes latched again, by repeating the write 00h-&gt;01h 
procedure.<BR>
This is supposed for &lt;reading&gt; from the RTC registers. It is proof to 
read the latched (frozen) time from the RTC registers, while the clock 
itself continues to tick in background.<BR>
<BR>
<B>The Clock Counter Registers<BR>
</B><TABLE><TR><TD><PRE>  08h  RTC S   Seconds   0-59 (0-3Bh)
  09h  RTC M   Minutes   0-59 (0-3Bh)
  0Ah  RTC H   Hours     0-23 (0-17h)
  0Bh  RTC DL  Lower 8 bits of Day Counter (0-FFh)
  0Ch  RTC DH  Upper 1 bit of Day Counter, Carry Bit, Halt Flag
        Bit 0  Most significant bit of Day Counter (Bit 8)
        Bit 6  Halt (0=Active, 1=Stop Timer)
        Bit 7  Day Counter Carry Bit (1=Counter Overflow)
</TD></TR></TABLE>The Halt Flag is supposed to be set before &lt;writing&gt; to the RTC 
Registers.<BR>
<BR>
<B>The Day Counter<BR>
</B>The total 9 bits of the Day Counter allow to count days in range from 
0-511 (0-1FFh). The Day Counter Carry Bit becomes set when this value 
overflows. In that case the Carry Bit remains set until the program does 
reset it.<BR>
Note that you can store an offset to the Day Counter in battery RAM. For 
example, every time you read a non-zero Day Counter, add this Counter to 
the offset in RAM, and reset the Counter to zero. This method allows to 
count any number of days, making your program Year-10000-Proof, provided 
that the cartridge gets used at least every 511 days.<BR>
<BR>
<B>Delays<BR>
</B>When accessing the RTC Registers it is recommended to execute a 4ms 
delay (4 Cycles in Normal Speed Mode) between the separate accesses.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="huc1mbcwithinfraredcontroller"></A><FONT SIZE=+2>&nbsp;HuC1 (MBC with Infrared Controller)</FONT></TD></TR></TABLE><BR>
This controller (made by Hudson Soft) appears to be very similar to an 
MBC1 with the main difference being that it supports infrared LED input 
/ output. (Similiar to the infrared port that has been later invented in 
CGBs.)<BR>
<BR>
The Japanese cart "Fighting Phoenix" (internal cart name: SUPER B DAMAN) 
is known to contain this chip.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="mbctimingissues"></A><FONT SIZE=+2>&nbsp;MBC Timing Issues</FONT></TD></TR></TABLE><BR>
<B>Using MBCs with CGB Double Speed Mode<BR>
</B>The MBC5 has been designed to support CGB Double Speed Mode.<BR>
There have been rumours that older MBCs (like MBC1-3) wouldn't be fast 
enough in that mode. If so, it might be nethertheless possible to use 
Double Speed during periods which use only code and data which is 
located in internal RAM.<BR>
However, despite of the above, my own good old selfmade MBC1-EPROM card 
appears to work stable and fine even in Double Speed Mode though.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="gamegeniesharkcheats"></A><FONT SIZE=+2>&nbsp;Gamegenie/Shark Cheats</FONT></TD></TR></TABLE><BR>
Game Shark and Gamegenie are external cartridge adapters that can be 
plugged between the gameboy and the actual game cartridge. Hexadecimal 
codes can be then entered for specific games, typically providing things 
like Infinite Sex, 255 Cigarettes, or Starting directly in Wonderland 
Level PRO, etc.<BR>
<BR>
<B>Gamegenie (ROM patches)<BR>
</B>Gamegenie codes consist of nine-digit hex numbers, formatted as 
ABC-DEF-GHI, the meaning of the separate digits is:<BR>
<TABLE><TR><TD><PRE>  AB    New data
  FCDE  Memory address, XORed by 0F000h
  GI    Old data, XORed by 0BAh and rotated left by two
  H     Don't know, maybe checksum and/or else
</TD></TR></TABLE>The address should be located in ROM area 0000h-7FFFh, the adapter 
permanently compares address/old data with address/data being read by 
the game, and replaces that data by new data if necessary. That method 
(more or less) prohibits unwanted patching of wrong memory banks. 
Eventually it is also possible to patch external RAM ?<BR>
Newer devices reportedly allow to specify only the first six digits 
(optionally). As far as I rememeber, around three or four codes can be 
used simultaneously.<BR>
<BR>
<B>Game Shark (RAM patches)<BR>
</B>Game Shark codes consist of eight-digit hex numbers, formatted as 
ABCDEFGH, the meaning of the separate digits is:<BR>
<TABLE><TR><TD><PRE>  AB    External RAM bank number
  CD    New Data
  GHEF  Memory Address (internal or external RAM, A000-DFFF)
</TD></TR></TABLE>As far as I understand, patching is implement by hooking the original 
VBlank interrupt handler, and re-writing RAM values each frame. The 
downside is that this method steals some CPU time, also, it cannot be 
used to patch program code in ROM.<BR>
As far as I rememeber, somewhat 10-25 codes can be used simultaneously.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="powerupsequence"></A><FONT SIZE=+2>&nbsp;Power Up Sequence</FONT></TD></TR></TABLE><BR>
When the GameBoy is powered up, a 256 byte program starting at memory 
location 0 is executed. This program is located in a ROM inside the 
GameBoy. The first thing the program does is read the cartridge 
locations from $104 to $133 and place this graphic of a Nintendo logo on 
the screen at the top. This image is then scrolled until it is in the 
middle of the screen. Two musical notes are then played on the internal 
speaker. Again, the cartridge locations $104 to $133 are read but this 
time they are compared with a table in the internal rom. If any byte 
fails to compare, then the GameBoy stops comparing bytes and simply 
halts all operations. If all locations compare the same, then the 
GameBoy starts adding all of the bytes in the cartridge from $134 to 
$14d. A value of 25 decimal is added to this total. If the least 
significant byte of the result is a not a zero, then the GameBoy will 
stop doing anything. If it is a zero, then the internal ROM is disabled 
and cartridge program execution begins at location $100 with the 
following register values:<BR>
<BR>
<TABLE><TR><TD><PRE>   AF=$01B0
   BC=$0013
   DE=$00D8
   HL=$014D
   Stack Pointer=$FFFE
   [$FF05] = $00   ; TIMA
   [$FF06] = $00   ; TMA
   [$FF07] = $00   ; TAC
   [$FF10] = $80   ; NR10
   [$FF11] = $BF   ; NR11
   [$FF12] = $F3   ; NR12
   [$FF14] = $BF   ; NR14
   [$FF16] = $3F   ; NR21
   [$FF17] = $00   ; NR22
   [$FF19] = $BF   ; NR24
   [$FF1A] = $7F   ; NR30
   [$FF1B] = $FF   ; NR31
   [$FF1C] = $9F   ; NR32
   [$FF1E] = $BF   ; NR33
   [$FF20] = $FF   ; NR41
   [$FF21] = $00   ; NR42
   [$FF22] = $00   ; NR43
   [$FF23] = $BF   ; NR30
   [$FF24] = $77   ; NR50
   [$FF25] = $F3   ; NR51
   [$FF26] = $F1-GB, $F0-SGB ; NR52
   [$FF40] = $91   ; LCDC
   [$FF42] = $00   ; SCY
   [$FF43] = $00   ; SCX
   [$FF45] = $00   ; LYC
   [$FF47] = $FC   ; BGP
   [$FF48] = $FF   ; OBP0
   [$FF49] = $FF   ; OBP1
   [$FF4A] = $00   ; WY
   [$FF4B] = $00   ; WX
   [$FFFF] = $00   ; IE
</TD></TR></TABLE><BR>
It is not a good idea to assume the above values will always exist. A 
later version GameBoy could contain different values than these at 
reset. Always set these registers on reset rather than assume they are 
as above.<BR>
<BR>
Please note that GameBoy internal RAM on power up contains random data. 
All of the GameBoy emulators tend to set all RAM to value $00 on entry.<BR>
<BR>
Cart RAM the first time it is accessed on a real GameBoy contains random 
data. It will only contain known data if the GameBoy code initializes it 
to some value.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="reducingpowerconsumption"></A><FONT SIZE=+2>&nbsp;Reducing Power Consumption</FONT></TD></TR></TABLE><BR>
The following can be used to recude the power consumption of the 
gameboy, and to extend the life of the batteries.<BR>
<BR>
<A HREF="#pwrusingthehaltinstruction">PWR Using the HALT Instruction</A><BR>
<A HREF="#pwrusingthestopinstruction">PWR Using the STOP Instruction</A><BR>
<A HREF="#pwrdisabelingthesoundcontroller">PWR Disabeling the Sound Controller</A><BR>
<A HREF="#pwrnotusingcgbdoublespeedmode">PWR Not using CGB Double Speed Mode</A><BR>
<A HREF="#pwrusingtheskills">PWR Using the Skills</A><BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="pwrusingthehaltinstruction"></A><FONT SIZE=+2>&nbsp;PWR Using the HALT Instruction</FONT></TD></TR></TABLE><BR>
It is recommended that the HALT instruction be used whenever possible to 
reduce power consumption & extend the life of the batteries. This 
command stops the system clock reducing the power consumption of both 
the CPU and ROM.<BR>
<BR>
The CPU will remain suspended until an interrupt occurs at which point 
the interrupt is serviced and then the instruction immediately following 
the HALT is executed.<BR>
<BR>
Depending on how much CPU time is required by a game, the HALT 
instruction can extend battery life anywhere from 5 to 50% or possibly 
more.<BR>
<BR>
When waiting for a vblank event, this would be a BAD example:<BR>
<TABLE><TR><TD><PRE>  @@wait:
   ld   a,(0FF44h)      ;LY
   cp   a,144
   jr   nz,@@wait
</TD></TR></TABLE><BR>
A better example would be a procedure as shown below. In this case the 
vblank interrupt must be enabled, and your vblank interrupt procedure 
must set vblank_flag to a non-zero value.<BR>
<TABLE><TR><TD><PRE>   ld   hl,vblank_flag  ;hl=pointer to vblank_flag
   xor  a               ;a=0
  @@wait:               ;wait...
   halt                 ;suspend CPU - wait for ANY interrupt
   cp   a,(hl)          ;vblank flag still zero?
   jr   z,@@wait        ;wait more if zero
   ld   (hl),a          ;set vblank_flag back to zero
</TD></TR></TABLE>The vblank_flag is used to determine whether the HALT period has been 
terminated by a vblank interrupt, or by another interrupt. In case that 
your program has all other interrupts disabled, then it would be proof 
to replace the above procedure by a single HALT instruction.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="pwrusingthestopinstruction"></A><FONT SIZE=+2>&nbsp;PWR Using the STOP Instruction</FONT></TD></TR></TABLE><BR>
The STOP instruction is intended to switch the gameboy into VERY low 
power standby mode. For example, a program may use this feature when it 
hasn't sensed keyboard input for a longer period (assuming that somebody 
forgot to turn off the gameboy).<BR>
<BR>
Before invoking STOP, it might be required to disable Sound and Video 
manually (as well as IR-link port in CGB). Much like HALT, the STOP 
state is terminated by interrupt events - in this case this would be 
commonly a joypad interrupt. The joypad register might be required to be 
prepared for STOP either.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="pwrdisabelingthesoundcontroller"></A><FONT SIZE=+2>&nbsp;PWR Disabeling the Sound Controller</FONT></TD></TR></TABLE><BR>
If your programs doesn't use sound at all (or during some periods) then 
write 00h to register FF26 to save 16% or more on GB power consumption.<BR>
Sound can be turned back on by writing 80h to the same register, all 
sound registers must be then re-initialized.<BR>
When the gameboy becomes turned on, sound is enabled by default, and 
must be turned off manually when not used.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="pwrnotusingcgbdoublespeedmode"></A><FONT SIZE=+2>&nbsp;PWR Not using CGB Double Speed Mode</FONT></TD></TR></TABLE><BR>
Because CGB Double Speed mode consumes more power, it'd be recommended 
to use normal speed when possible.<BR>
There's limited ability to switch between both speeds, for example, a 
game might use normal speed in the title screen, and double speed in the 
game, or vice versa.<BR>
However, during speed switch the display collapses for a short moment, 
so that it'd be no good idea to alter speeds within active game or title 
screen periods.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="pwrusingtheskills"></A><FONT SIZE=+2>&nbsp;PWR Using the Skills</FONT></TD></TR></TABLE><BR>
Most of the above power saving methods will produce best results when 
using efficient and tight assembler code which requires as less CPU 
power as possible. Thus, experienced old-school programmers will 
(hopefully) produce lower power consumption, as than HLL-programming 
teenagers, for example.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="spriterambug"></A><FONT SIZE=+2>&nbsp;Sprite RAM Bug</FONT></TD></TR></TABLE><BR>
There is a flaw in the GameBoy hardware that causes trash to be written 
to OAM RAM if the following commands are used while their 16-bit content 
is in the range of $FE00 to $FEFF:<BR>
<TABLE><TR><TD><PRE>  inc rr        dec rr          ;rr = bc,de, or hl
  ldi a,(hl)    ldd a,(hl)
  ldi (hl),a    ldd (hl),a
</TD></TR></TABLE>Only sprites 1 & 2 ($FE00 & $FE04) are not affected by these 
instructions.<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="externalconnectors"></A><FONT SIZE=+2>&nbsp;External Connectors</FONT></TD></TR></TABLE><BR>
<B>Cartridge Slot<BR>
</B><TABLE><TR><TD><PRE>  Pin   Name    Expl.
  1     VDD     Power Supply +5V DC
  2     PHI     System Clock
  3     /WR     Write
  4     /RD     Read
  5     /CS     Chip Select
  6-21  A0-A15  Address Lines
  22-29 D0-D7   Data Lines
  30    /RES    Reset signal
  31    VIN     External Sound Input
  32    GND     Ground
</TD></TR></TABLE><BR>
<B>Link Port<BR>
</B>Pin numbers are arranged as 2,4,6 in upper row, 1,3,5 un lower row; 
outside view of gameboy socket; flat side of socket upside.<BR>
Colors as used in most or all standard link cables, because SIN and SOUT 
are crossed, colors Red and Orange are exchanged at one cable end.<BR>
<TABLE><TR><TD><PRE>  Pin Name Color  Expl.
  1   VCC  -      +5V DC
  2   SOUT red    Data Out
  3   SIN  orange Data In
  4   P14  -      Not used
  5   SCK  green  Shift Clock
  6   GND  blue   Ground
</TD></TR></TABLE>Note: The original gameboy used larger plugs (unlike pocket gameboys and 
newer), linking between older/newer gameboys is possible by using cables 
with one large and one small plug though.<BR>
<BR>
<B>Stereo Sound Connector (3.5mm, female)<BR>
</B><TABLE><TR><TD><PRE>  Pin     Expl.
  Tip     Sound Left
  Middle  Sound Right
  Base    Ground
</TD></TR></TABLE><BR>
<B>External Power Supply<BR>
</B>...<BR>
<BR>
<BR>
<BR>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><A NAME="end"></A><FONT SIZE=+2>&nbsp;END</FONT></TD></TR></TABLE></BODY></HTML>

